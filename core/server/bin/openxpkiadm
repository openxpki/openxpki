#!/usr/bin/perl -w

use strict;
use warnings;
use English;
use OpenXPKI::Debug;
use OpenXPKI::Control;
use Getopt::Long;
use Pod::Usage;
use POSIX ":sys_wait_h";
use Errno;
use File::Spec;

# For the password hasher
use IO::Prompt;
use Digest::SHA;
use Digest::MD5;
use Proc::SafeExec;
use MIME::Base64;

use OpenXPKI::Server::Init;
use OpenXPKI::i18n;
use OpenXPKI::Server::Context qw( CTX );

use OpenXPKI::VERSION;

use Data::Dumper;

my %params;
my @options_spec = ('config=s','instance|i=s');
my $cmd = shift || 'help';
my $ret = 255;


sub certificate_id {

    my $format = $params{format} || 'openxpki';

    my $filename = $params{file};

    if ( !-r $filename ) {
        print STDERR "ERROR: filename '$filename' is not readable\n";
        return 2;
    }

    if ($format eq 'openssl') {
        my @exec = ('openssl','x509','-noout','-hash','-inform','PEM','-in', $filename);
        my ($id, undef) = Proc::SafeExec::backtick(@exec);
        chomp $id;
        print "$id\n";
        return 0;
    } elsif ($format ne 'openxpki') {
        print STDERR "Invalid format - supported formats are openssl|openxpki\n";
        return 1;
    }

    my $FileUtils = OpenXPKI::FileUtils->new();
    my $certdata  = $FileUtils->read_file($filename);

    if ( !defined $certdata ) {
        print STDERR "ERROR: Could not parse certificate data\n";
        return 2;
    }

    my ($extracted_certdata) = $certdata =~ m{ \A .* (-----BEGIN\ CERTIFICATE----- .* -----END\ CERTIFICATE-----) .* \z}xms;


    my $res = CTX('api')->get_cert_identifier({ 'CERT' => $extracted_certdata });

    print $res;
    print "\n";

    return 0;

 }

sub certificate_import {

    print STDERR "Starting import\n";

    my $filename = $params{file};

    if ( !-r $filename ) {
        print STDERR "ERROR: filename '$filename' is not readable\n";
        return 2;
    }

    my $FileUtils = OpenXPKI::FileUtils->new();
    my $certdata  = $FileUtils->read_file($filename);

    if ( !defined $certdata ) {
        print STDERR "ERROR: Could not parse certificate data\n";
        return 2;
    }

    my ($extracted_certdata) = $certdata =~ m{ \A .* (-----BEGIN\ CERTIFICATE----- .* -----END\ CERTIFICATE-----) .* \z}xms;

    my $api_param = { DATA => $extracted_certdata };

    if ($params{issuer}) {
        $api_param->{ISSUER} = $params{issuer};
    }

    if ($params{realm}) {
        $api_param->{PKI_REALM} = $params{realm};
    }

    if ($params{"force-no-chain"}) {
        $api_param->{FORCE_NOCHAIN} = 1;
    }

    if ($params{"force-no-verify"}) {
        $api_param->{FORCE_NOVERIFY} = 1;
    }

    if ($params{"force-issuer"}) {
        if (!$params{issuer}) {
            die "You need to specify the issuer with --issuer when using --force-issuer\n"
        }
        $api_param->{FORCE_ISSUER} = 1;
    }

    if ($params{"force-certificate-already-exists"}) {
        $api_param->{UPDATE} = 1;
    }

    if ($params{revoked}) {
        $api_param->{REVOKED} = 1;
    }

    my $res = CTX('api')->import_certificate( $api_param );

    print "Successfully imported certificate into database:\n";
    print "  Subject:    " . $res->{SUBJECT} . "\n";
    print "  Issuer:     " . $res->{ISSUER_DN} . "\n";
    print "  Identifier: " . $res->{IDENTIFIER} . "\n";
    print "  Realm:      " . ($res->{PKI_REALM} || 'none'). "\n";

    my $return = 0;

    # directly register alias
    if ($params{alias} || $params{gen} || $params{token}) {
        if (!$params{realm}) {
            if (!$res->{PKI_REALM}) {
                print "*Unable to register alias without realm!*\n";
            } else {
                $params{realm} = $res->{PKI_REALM};
            }
        }
        $params{identifier} = $res->{IDENTIFIER};
        print "\n";
        if ($params{realm}) {
            $return = alias_add();
        }
    }

    return $return;
}


sub certificate_remove {

    my $name  = $params{name};
    my $realm = $params{realm};

    my $identifier = $name;

    if ( $realm ) {
        $identifier = __resolve_alias({
            NAME  => $name,
            REALM => $realm,
        });
    } else {
        $realm = '_any';
    }

    # we dont need those checks if force-is-issuer is set
    if (!defined $params{'force-is-issuer'}) {

        # check if certificate is issuer of something
        my $cnt = CTX('api')->search_cert_count({
            ISSUER_IDENTIFIER => $identifier,
            PKI_REALM => $realm,
        });

        my $is_issuer = 0;
        if ($cnt > 1) {
            # this is definitly an active issuer certificate
            $is_issuer = 1;
        } elsif ($cnt == 1) {
            # might be a self-signed certificate
            my $cert = CTX('api')->search_cert({
                ISSUER_IDENTIFIER => $identifier,
                PKI_REALM => $realm
            });
            $is_issuer = ( $cert->[0]->{'ISSUER_IDENTIFIER'} ne $identifier );
        }

        if ( $is_issuer ) {
            print STDERR "ERROR: Certificate not deleted because it is referenced as the issuer of "
                . $cnt . " certificate(s) in the database.\n";
            return 2;
        }
    }

    my $dbi = CTX('dbi');
    my $certificate = $dbi->select_one(
        from   => 'certificate',
        columns => ['identifier'],
        where => { identifier => $identifier, },
    );
    if ( defined $certificate ) {
        $dbi->delete(
            from => 'certificate',
            where  => { identifier => $identifier, },
        );
        $dbi->commit();
        print "Successfully deleted certificate $name "
          . "(identifier: $identifier) from database.\n";
        return 0;
    }
    else {
        print STDERR "ERROR: Certificate $name "
          . "(identifier: $identifier) not found in database.\n";
        return 2;
    }
}

sub alias_add {

    my %insert_hash = ();

    $insert_hash{PKI_REALM} = $params{realm};

    my $dbi = CTX('dbi');
    # Import is possible with symbolic token or group name
    if ( $params{token} || $params{group} ) {

        my $group;
        if ($params{group}) {
            $group = $params{group};
        } else {
            $group = ($params{token} eq "root") ? 'root' :
                CTX('config')->get(['realm', $params{realm}, 'crypto','type', $params{token}]);

            if (!$group) {
                print STDERR "There is no token of type $params{token} defined\n";
                return 2;
            }
        }

        # explicit generation
        if ($params{gen} && $params{gen} =~ m{\A \d+ \z}x) {

            # check for duplicate
            my $check_duplicate = $dbi->select_one(
                from   => 'aliases',
                columns => ['*'],
                where => {
                    pki_realm => $params{realm},
                    group_id => $group,
                    generation => $params{gen}
                }
            );
            if ($check_duplicate) {
                print STDERR sprintf("A token with generation %01d for group %s already exists:\n",
                    $params{gen}, $params{token}, $check_duplicate->{identifier});
                __alias_print($check_duplicate);
                return 2;
            }

           $insert_hash{generation} = $params{gen};

        # no generation, autodetected
        } else {

            # query aliases to get next generation id
            my $next_generation = $dbi->select_one(
                from   => 'aliases',
                columns => ['*'],
                where => {
                    pki_realm => $params{realm},
                    group_id => $group,
                },
                order_by => '-generation',
            );
            $insert_hash{generation} = ($next_generation->{generation} || 0) + 1;
        }
        $insert_hash{group_id} = $group;
        $insert_hash{alias} = sprintf "%s-%01d", $group, $insert_hash{generation};

    } elsif ( !exists( $params{alias} ) || $params{alias} eq '' ) {
        print STDERR "Please specify an alias with --alias\n";
        return 1;

    } else {

        $insert_hash{alias} = $params{alias};
    }

    if ( !exists( $params{identifier} ) || $params{identifier} eq '' ) {
        print STDERR "Please specify an identifier with --identifier\n";
        return 1;
    } else {
        $insert_hash{identifier} = $params{identifier};
    }

    # Prevent duplicate entries (each identifier is allowed only once per group)
    my $duplicate_alias = $dbi->select_one(
        from   => 'aliases',
        columns => ['*'],
        where => {
            identifier => $insert_hash{identifier},
            pki_realm => $params{realm},
            group_id => $insert_hash{group_id}
        },
    );

    if ($duplicate_alias) {
        print STDERR "ERROR: certificate already exisits in group\n";
        print STDERR "Alias: " . $duplicate_alias->{alias} . "\n";
        return 2;
    }

    # query certificate table to check whether --identifer actually exists
    my $certificate = $dbi->select_one(
        from    => 'certificate',
        columns => ['*'],
        where => {
            identifier => $insert_hash{identifier}
        },
    );

    if ( !defined $certificate ) {
        # there is no cert with given identifier
        print STDERR "ERROR: Could not find a certificate with "
          . "identifier '$insert_hash{identifier}', ";
        return 2;
    }

    if ($params{notbefore}) {
        if ($params{notbefore} =~ /^\d+$/) {
            $insert_hash{NOTBEFORE} = $params{notbefore};
        } else {

            my $dt;
            eval {
                $dt = OpenXPKI::DateTime::parse_date_utc( $params{notbefore} );
            };
            if ($EVAL_ERROR || !$dt) {
                print STDERR "ERROR: Could not parse notbefore date";
                return 1;
            }

            $insert_hash{notbefore} = $dt->epoch();

            if ($insert_hash{notbefore} < $certificate->{notbefore}) {
                print STDERR "ERROR: notbefore exceeds certificate validity";
                return 1;
            }
        }
    } else {
        $insert_hash{notbefore} = $certificate->{notbefore};
    }


    if ($params{notafter}) {
        if ($params{notafter} =~ /^\d+$/) {
            $insert_hash{notafter} = $params{notafter};
        } else {
            my $dt;
            eval {
                $dt = OpenXPKI::DateTime::parse_date_utc( $params{notafter} );
            };
            if ($EVAL_ERROR || !$dt) {
                print STDERR "ERROR: Could not parse notafter date";
                return 1;
            }
            $insert_hash{notafter} = $dt->epoch();

            if ($insert_hash{notafter} > $certificate->{notafter}) {
                print STDERR "ERROR: notafter exceeds certificate validity";
                return 1;
            }
        }
    } else {
        $insert_hash{notafter} = $certificate->{notafter};
    }

    #### insert_hash : Dumper(\%insert_hash)
    $dbi->insert(
        into => 'aliases',
        values  => \%insert_hash,
    );
    $dbi->commit();

    print "Successfully created alias in realm $params{realm}:\n";
    __alias_print( \%insert_hash );


    # Check if the alias is for an issuing ca cert -> create root ca alias
    my $cs_group = CTX('config')->get(['realm', $params{realm}, 'crypto', 'type', 'certsign']);
    if ( $insert_hash{alias} =~ /^$cs_group-(\d+)/ ) {
        print "\nToken is certsign, looking for root...\n";
        my $gen = $1;

        my $chain_ref = CTX('api')->get_chain({ 'START_IDENTIFIER' => $insert_hash{identifier} });

        if ($chain_ref->{COMPLETE} != 1) {
            print STDERR "ERROR: unable to find root certificate";
            return 2;
        }
        my $root_identifier = pop @{$chain_ref->{IDENTIFIERS}};

        # check if this root is already defined
        my $root_alias = $dbi->select_one(
            from   => 'aliases',
            columns => ['*'],
            where => {
                identifier => $root_identifier,
                pki_realm => $params{realm},
                group_id => 'root'
            },
        );
        if ($root_alias) {
            print "Root ca already in alias table:\n";
        } else {
            print "Creating alias for root ca:\n";
            # Get the notebefore/notafter date
            $certificate = $dbi->select_one(
                from   => 'certificate',
                columns => ['notbefore' , 'notafter' ],
                where => { identifier => $root_identifier },
            );

            $root_alias = {
                identifier => $root_identifier,
                pki_realm => $params{realm},
                group_id => 'root',
                generation => $gen,
                alias => sprintf ('root-%01d', $gen),
                notbefore => $certificate->{notbefore},
                notafter => $certificate->{notafter},
            };
            $dbi->insert(
                into => 'aliases',
                values  => $root_alias,
            );
            $dbi->commit();
        }

        __alias_print( $root_alias );

    }

    return 0;

}

sub alias_update {

    my %query_hash = (
        pki_realm =>  $params{realm}
    );

    if ($params{identifier}) {
        $query_hash{identifier} = $params{identifier};
    } elsif ($params{alias}) {
        $query_hash{alias} = $params{alias};
    } else {
        print STDERR "You must specify either --identifier or --alias\n";
        return 1;
    }

    my $dbi = CTX('dbi');

    my $alias = $dbi->select_one(
        from   => 'aliases',
        columns => ['*'],
        where => \%query_hash,
    );

    if (!$alias) {
        print STDERR "No alias entry found matching your request\n";
        return 2;
    }

    my %update_hash = ();

    # query certificate table to check whether --identifer actually exists
    my $certificate = $dbi->select_one(
        from   => 'certificate',
        columns => ['*'],
        where => { identifier => $alias->{identifier}, },
    );

    if ($params{notbefore}) {
        if ($params{notbefore} =~ /^\d+$/) {
            $update_hash{notbefore} = $params{notbefore};
        } else {
            my $dt;
            eval {
                $dt = OpenXPKI::DateTime::parse_date_utc( $params{notbefore} );
            };
            if ($EVAL_ERROR || !$dt) {
                print STDERR "ERROR: Could not parse notbefore date";
                return 2;
            }
            $update_hash{notbefore} = $dt->epoch();
        }
        if ($update_hash{notbefore} < $certificate->{notbefore}) {
            print STDERR "ERROR: notbefore exceeds certificate validity";
            return 2;
        }
    } elsif(defined $params{notbefore}) {
        # this passed the literal 0 used to reset the date!
        $update_hash{notbefore} = $certificate->{notbefore};
    }

    if ($params{notafter}) {
        if ($params{notafter} =~ /^\d+$/) {
            $update_hash{notafter} = $params{notafter};
        } else {
            my $dt;
            eval {
                $dt = OpenXPKI::DateTime::parse_date_utc( $params{notafter} );
            };
            if ($EVAL_ERROR || !$dt) {
                print STDERR "ERROR: Could not parse notafter date";
                return 2;
            }
            $update_hash{notafter} = $dt->epoch();
        }
        if ($update_hash{notafter} > $certificate->{notafter}) {
            print STDERR "ERROR: notafter exceeds certificate validity";
            return 2;
        }
    } elsif(defined $params{notafter}) {
        # this passed the literal 0 used to reset the date!
        $update_hash{notafter} = $certificate->{notafter};
    }

    if (!%update_hash) {
        print STDERR "ERROR: please specify at least notbefore or notafter";
        return 1;
    }

    $dbi->update(
        table => 'aliases',
        set => \%update_hash,
        where => {
            alias =>  $alias->{alias},
            pki_realm => $alias->{pki_realm}
        }
    );
    $dbi->commit();

    $alias = $dbi->select_one(
        from   => 'aliases',
        columns => ['*'],
        where => \%query_hash,
    );

    print "Successfully updated alias:\n";
    __alias_print( $alias );


    return 0;

}

sub alias_list {

    my $realm = $params{realm};
    # get names of groups
    my $groups = CTX('config')->get_hash(['realm',$realm,'crypto','type']);

    my $dbi = CTX('dbi');
    my $alias;
    my $db_alias;
    my $cert;
    my $filter = $params{filter} || 'current';
    my $show_subject = $params{subject} ? 1 :0;

    # Prepare template for where part based on filter
    my $where = { 'pki_realm' => { value => $realm } };
    my $limit = 999;
    if ($filter ne 'all') {
        # not all => active or current
        my $now = time();
        $where->{'notbefore'} = { '<' => $now };
        $where->{'notafter'} = { '>' => $now };

        # Current is only the latest one
        if ($filter ne 'active') {
            $limit = 1;
        }
    }

    # No group list
    if ($params{nogroup}) {
        $where->{group_id} = undef;
        $db_alias = $dbi->select(
            from   => 'aliases',
            columns => ['*'],
            where =>  $where,
            order_by => [ '-alias', '-notbefore' ],
        );

        print "=== alias without group ===\n" if ($db_alias->rows);
        while (my $alias = $db_alias->fetchrow_hashref) {
            __alias_print( $alias, $show_subject);
        }
        return 0;
    }

    if ($params{group}) {
        $where->{group_id} = $params{group};
    } else {
        $where->{group_id} = { '!=', '' };
    }

    # Load the list of exisiting aliased groups as there can be custom tokens
    # outside the main groups (e.g. alternative scep tokens)
    my $db_results = $dbi->select(
        from  => 'aliases',
        columns => ['*'],
        where => $where,
        order_by => '-notbefore',
    );

    my %anon_groups;
    while (my $entry = $db_results->fetchrow_hashref) {
        $anon_groups{ $entry->{group_id} } = 1;
    }
    # remove root from the list
    delete $anon_groups{'root'};

    print "=== functional token ===\n" if (!$params{group});
    foreach my $type (keys %{$groups}) {

        my $group = $groups->{$type};

        next if ($params{group} && $group ne $params{group});

        print "$group ($type):\n";

        $where->{'group_id'} = $group;

        $db_alias = $dbi->select(
            from   => 'aliases',
            columns => ['*'],
            where =>  $where,
            limit => $limit,
            order_by => [ '-notbefore' ],
        );

        while (my $alias = $db_alias->fetchrow_hashref) {
            __alias_print( $alias, $show_subject );
        }

        # print empty message if none found and not in group mode
        if (!$db_alias->rows) {
            __alias_print( undef );
        }

        # unset in anon group list
        delete $anon_groups{$group};

    }

    print "=== anonymous groups ===\n" if (%anon_groups);
    foreach my $group (keys %anon_groups) {

        print "$group:\n";

        $where->{'group_id'} = $group;

        $db_alias = $dbi->select(
            from   => 'aliases',
            columns => ['*'],
            where =>  $where,
            limit => $limit,
            order_by => [ '-notbefore' ],
        );

        while (my $alias = $db_alias->fetchrow_hashref) {
            __alias_print( $alias, $show_subject );
        }

    }

    # do not proceed in group mode
    return 0 if ($params{group});

    # Check for root ca
    $alias = $dbi->select_one(
        from    => 'aliases',
        columns => ['*'],
        where => {
            'pki_realm' => $realm,
            'group_id' => 'root',
            'notbefore' => { '<' => time() },
            'notafter' => { '>' => time() },
        },
        order_by => '-notbefore'
    );

    print "=== root ca ===\ncurrent root ca:\n";
    __alias_print( $alias, $show_subject );

    # Check for root ca
    $alias = $dbi->select_one(
        from   => 'aliases',
        columns => ['*'],
        where => {
            'pki_realm' => $realm,
            'group_id' => 'root',
            'notbefore' => { '>', time() },
        },
        order_by => '-notbefore',
    );

    print "upcoming root ca:\n";
    __alias_print( $alias, $show_subject );


    return 0;


}

sub __alias_print {

    my $alias = shift;
    my $subject = shift;

    if (!$alias || !$alias->{alias}) {
        print "  not set\n\n";
        return;
    }

    my $cert = CTX('api')->get_cert({ IDENTIFIER => $alias->{identifier}, FORMAT => 'DBINFO' });

    print "  Alias     : $alias->{alias}\n";
    print "  Identifier: $alias->{identifier}\n";

    print "  Subject   : $cert->{SUBJECT}\n" if ($subject);

    print "  NotBefore : " . DateTime->from_epoch( epoch => $alias->{notbefore} )->strftime("%F %T");
    print DateTime->from_epoch( epoch => $cert->{NOTBEFORE} )->strftime(" (%F %T)")
        if ($cert && $cert->{NOTBEFORE} != $alias->{notbefore});

    print "\n";
    print "  NotAfter  : " . DateTime->from_epoch( epoch => $alias->{notafter} )->strftime("%F %T");

    print DateTime->from_epoch( epoch => $cert->{NOTAFTER} )->strftime(" (%F %T)")
        if ($cert && $cert->{NOTAFTER} != $alias->{notafter});

    print "\n\n";

}


sub certificate_chain {

    my $cert_name;
    my $issuer_name;
    if ( !exists( $params{name} ) || $params{name} eq '' ) {
        print STDERR "Please specify a certificate name with --name\n";
        return 1;
    }
    else {
        $cert_name = $params{name};
    }
    if ( !exists( $params{issuer} ) || $params{issuer} eq '' ) {
        print STDERR "Please specify an issuer name with --issuer\n";
        return 1;
    }
    else {
        $issuer_name = $params{issuer};
    }

    # maybe the certificate name is an alias, try to resolve it
    my $cert_identifier = __resolve_alias({
        NAME  => $cert_name,
        REALM => $params{realm},
    });

    # check whether the certificate is in the DB
    my $certificate = CTX('dbi')->select_one(
        columns => [ '*' ],
        from => 'certificate',
        where => {
            'identifier' => $cert_identifier,
            pki_realm  => $params{realm}
        }
    );

    if ( !defined $certificate
        && !defined $params{'force-certificate-not-found'} )
    {
        print STDERR "ERROR: Certificate '$cert_name' not found in realm "
          . "$params{realm}.\n";
        return 2;
    }

    my $issuer_identifier;

    # maybe the issuer name is an alias, try resolve it
    my $realm;
    if ( defined $params{'issuer-realm'} ) {
        $realm = $params{'issuer-realm'};
    }
    else {
        $realm = $params{realm};
    }
    $issuer_identifier = __resolve_alias({
        NAME  => $issuer_name,
        REALM => $realm,
    });

    my $dbi = CTX('dbi');
    # check whether the issuer is in the DB
    my $issuer = $dbi->select_one(
        columns => [ '*' ],
        from => 'certificate',
        where => {
            'identifier' => $issuer_identifier},
    );
    if ( !defined $issuer
        && !defined $params{'force-issuer-certificate-not-found'} )
    {
        print STDERR "ERROR: Issuer certificate '$issuer_name' "
          . "(identifier: $issuer_identifier) not found in database.\n";
        return 2;
    }

    # set the issuer_identifier for the given certificate
    $dbi->update(
        table => 'certificate',
        set  => { issuer_identifier => $issuer_identifier },
        where => {
            cert_key => $certificate->{cert_key},
            identifier      => $cert_identifier,
            pki_realm       => $certificate->{pki_realm},
        },
    );
    $dbi->commit();
    print "Successfully set $issuer_name (identifier: $issuer_identifier) "
      . "as issuer of certificate $cert_name (identifier: "
      . "$cert_identifier).\n";

    # TODO: maybe don't warn only, but let the user use --force to
    # specify that he knows what he is doing ...?
    if ( $issuer->{subject_key_identifier} ne
        $certificate->{authority_key_identifier} )
    {
        print STDERR "WARNING: The issuer's subject key identifier "
          . "extension ($issuer->{SUBJECT_KEY_IDENTIFIER}) does not "
          . "match the authority key identifier extension contained "
          . "in the certificate "
          . "($certificate->{authority_key_identifier}). Are you sure "
          . "your chain is correct?\n";
    }
    if ( $issuer->{subject} ne $certificate->{issuer_dn} ) {
        print STDERR "WARNING: The issuer's subject ($issuer->{SUBJECT}) "
          . "does not match the issuer DN contained in the certificate "
          . "($certificate->{ISSUER_DN}). Are you sure your chain is "
          . "correct?\n";
    }
    return 0;

}

sub certificate_list {

    my @realms;
    if ( defined $params{realm} ) {
        push @realms, $params{realm};
    }
    else {
        @realms = CTX('config')->get_keys(['system','realms']);
        push @realms, undef;  # add the magic empty realm
    }

    my $dbi = CTX('dbi');
    foreach my $realm (@realms) {
        if ( defined $realm ) {
            print "\nCertificates in $realm:\n";
        }
        else {
            print "\nCertificates in self-signed pseudo-realm:\n";
        }
        my $certificates;
        if ( defined $params{all} ) {
            $certificates = $dbi->select(
                from   => 'certificate',
                columns => ['*'],
                where => { pki_realm => $realm, },
            );
        }
        else {
            $certificates = $dbi->select(
                from_join   => 'aliases aliases.identifier=certificate.identifier certificate',
                columns => [
                    'aliases.alias',
                    'aliases.identifier',
                    'certificate.subject',
                    'certificate.issuer_dn',
                    'certificate.cert_key',
                    'certificate.issuer_identifier',
                    'certificate.data',
                    'certificate.status',
                    'certificate.public_key',
                    'certificate.subject_key_identifier',
                    'certificate.authority_key_identifier',
                    'certificate.notafter',
                    'certificate.loa',
                    'certificate.notbefore',
                    'certificate.req_key',
                ],
                where => { 'aliases.pki_realm' => $realm, },
            );
        }

        while (my $cert = $certificates->fetchrow_hashref) {
            my $identifier;
            if ( defined $params{all} ) {    # look up aliases
                $identifier = $cert->{identifier};
                my $status = $cert->{status};
                if ( defined $status && $status eq 'REVOKED' ) {
                    print "\n  Identifier: "
                      . $cert->{identifier}
                      . " (REVOKED)\n";
                }
                else {
                    print "\n  Identifier: " . $cert->{identifier} . "\n";
                }
                my $aliases = $dbi->select(
                    from   => 'aliases',
                    columns => ['*'],
                    where => { identifier => $cert->{identifier}, },
                );
                while (my $alias = $aliases->fetchrow_hashref) {
                    print "    Alias:\n      "
                      . $alias->{alias} . " (in realm: " . $alias->{pki_realm} . ")\n";
                }
            }
            else {
                $identifier = $cert->{'identifier'};
                my $status = $cert->{'status'};
                if ( defined $status && $status eq 'REVOKED' ) {
                    print "\n  Identifier: "
                      . $cert->{'identifier'}
                      . " (REVOKED)\n";
                }
                else {
                    print "\n  Identifier: " . $cert->{'identifier'} . "\n";
                }
                print "    Alias:\n      "
                  . $cert->{'alias'} . "\n";
            }

            my $prefix = '';
            if ( defined $params{v} && $params{v} > 0 ) {

                # show subject and issuer dn
                my $subject   = $cert->{ 'subject' };
                my $issuer_dn = $cert->{ 'issuer_dn' };
                print "    Subject:\n      " . $subject . "\n";
                print "    Issuer DN:\n      " . $issuer_dn . "\n";
            }
            if ( defined $params{v} && $params{v} > 1 ) {

                # show chain
                my $chain = CTX('api')->get_chain( { START_IDENTIFIER => $identifier, } );
                my $chain_str = join( ' -> ', @{ $chain->{IDENTIFIERS} } );

                print "    Chain:\n      $chain_str";
                if ( $chain->{COMPLETE} == 1 ) {
                    print "(complete)\n";
                }
                else {
                    print "(INcomplete!)\n";
                }
            }
            if ( defined $params{v} && $params{v} > 2 ) {

                # show database entry
                my @fields = qw(
                  subject_key_identifier
                  authority_key_identifier
                  cert_key
                  issuer_identifier
                  status
                  notafter
                  notbefore
                  req_key
                );

                if ( $params{v} > 3 ) {
                    push @fields, qw(public_key data);
                }

                foreach my $field (@fields) {
                    my $value;
                    if ( defined $cert->{ $field } ) {
                        $value = $cert->{ $field };
                    }
                    else {
                        $value = 'NULL';
                    }
                    $field =~ s/_/ /g;
                    print "    $field:\n      " . $value . "\n";
                }
            }
        }
    }
    exit 0;
}

sub alias_del {

    my %delete_hash = ();

    $delete_hash{PKI_REALM} = $params{realm};

    if ($params{identifier}) {
        $delete_hash{identifier} = $params{identifier};
    } elsif ($params{alias}) {
        $delete_hash{alias} = $params{alias};
    } else {
        print STDERR "You must specify either --identifier or --alias\n";
        return 1;
    }

    my $dbi = CTX('dbi');
    my $alias = $dbi->select_one(
        from   => 'aliases',
        columns => ['*'],
        where => \%delete_hash,
    );

    if (!$alias) {
        print STDERR "No alias entry found matching your request\n";
        return 2;
    }

    $dbi->delete(
        from => 'aliases',
        where => {
            alias => $alias->{alias},
            pki_realm => $alias->{pki_realm},
        }
    );
    $dbi->commit();

    print "Successfully removed the alias $alias->{alias}:\n";
    print "   Identifier: $alias->{identifier}\n";
    print "   Realm:      $alias->{pki_realm}\n";

    return 0;

}

sub key_list {

    my $dbi = CTX('dbi');
    my $config = CTX('config');
    my $realm = $params{realm};

    # TODO - Improve!
    # We use the alias table to find all keys in the realm
    # For the moment we assume the keys are defined explicit in the config
    # this will change in the future when we allow autodiscovery and default inheritance
    my $token_class = $config->get_hash(['realm',$realm,'crypto','type']);

    foreach my $class (keys %{$token_class}) {
        my $db_alias = $dbi->select(
            from    => 'aliases',
            columns => ['*'],
            where => {
                group_id     => $token_class->{$class},
                pki_realm => $realm,
            },
        );

        print "Keys for token group $token_class->{$class}\n";
        while (my $entry = $db_alias->fetchrow_hashref) {
            my $alias = $entry->{alias};
            my $key = $config->get(['realm',$realm,'crypto','token',$alias,'key']);

            my $status_flag = '?';
            if (!$key) {
                $status_flag = 'c';
            } elsif ( -e $key && ( !-s $key ) ) {
                $status_flag = '0';    # file exists but is of size zero
            } elsif ( -e $key ) {        # file exists and is non-zero
                $status_flag = '+';
            } else {                     # file does not exist (yet)
                $status_flag = '!';
            }
            print '    ' . $status_flag . ' ' . $alias . "\n";
        }
    }

    return 0;
}

sub hash_password {

    print 'Please type your password, end with return: ';
    my $passwd = prompt -echo => '*';

    print "Please re-type your password: ";
    my $retype = prompt -echo => '*';

    chomp $passwd;
    chomp $retype;

    if (!$passwd) {
        return 0;
    }

    if ($passwd ne $retype) {
        print "Sorry, the passwords do not match\n";
        return 0;
    }

    # Use openssl to create the salt
    my @exec = ('openssl','rand','-base64','3');
    my ($salt, undef) = Proc::SafeExec::backtick(@exec);
    chomp $salt;

    my $computed_secret;
    if ($params{scheme} eq 'sha') {
        my $ctx = Digest::SHA->new();
        $ctx->add($passwd);
        $computed_secret = $ctx->b64digest();
    } elsif ($params{scheme} eq 'ssha') {
        my $ctx = Digest::SHA->new();
        $ctx->add($passwd);
        $ctx->add($salt);
        $computed_secret = encode_base64( $ctx->digest() . $salt, '');
    } elsif ($params{scheme} eq 'md5') {
        my $ctx = Digest::MD5->new();
        $ctx->add($passwd);
        $computed_secret = $ctx->b64digest();
    } elsif ($params{scheme} eq 'smd5') {
        my $ctx = Digest::MD5->new();
        $ctx->add($passwd);
        $ctx->add($salt);
        $computed_secret = encode_base64($ctx->digest() . $salt, '');
    } elsif ($params{scheme} eq 'crypt') {
        $computed_secret = crypt($passwd, $salt);
    }

    if (!$computed_secret) {
        die "Unable to compute hash\n";
    }

    printf "Your hashed password is: {%s}%s\n", $params{scheme}, $computed_secret;

    return 0;
}

sub __resolve_alias {

    my $arg_ref = shift;
    my $alias = CTX('dbi')->select_one(
        from => 'aliases',
        columns => [ 'identifier' ],
        where => {
            'alias'     => $arg_ref->{NAME},
            'pki_realm' => $arg_ref->{REALM},
        }
    );

    if (!$alias->{identifier}) {
        # likely it was an identifier already
        return $arg_ref->{NAME};
    }
    return $alias->{identifier};

}

sub __init {

    GetOptions( \%params, @options_spec ) or pod2usage( -verbose => 0 );

    if ($params{config}) {
        # we set the ENV here to outrule an external ENV setting and to have
        # it ready for the reload action (needed to find the correct pidfile)
        $ENV{OPENXPKI_CONF_PATH} = $params{config};
    } elsif ($params{instance}) {
        $ENV{OPENXPKI_CONF_PATH} = sprintf '/etc/openxpki/%s/config.d', $params{instance};
    }

}

sub __check_realm {

    my $realm = $params{realm};

    if (!$realm) {
         die "You must specify a realm using --realm\n";
    }

    if (!CTX('config')->exists(['system','realms',$params{realm}])) {
        die  "The realm $realm does not exist!\n";
    }

    return 1;
}

eval {

if ($cmd eq 'initdb') {

    push @options_spec, qw(dry-run force);
    die "initdb is no longer supported!\nPlease use the provided schema dumps to setup your database.";

} elsif ($cmd eq 'certificate') {

    my $subcmd = shift;

    if ($subcmd eq 'id') {

        push @options_spec, qw(
            file=s
            format=s
        );
        __init();

        OpenXPKI::Server::Init::init({TASKS  => ['config_versioned','log','dbi_log','api','crypto_layer','dbi'], SILENT => 1, CLI => 1});

        $ret = certificate_id();

    } elsif ($subcmd eq 'import') {

        push @options_spec, qw(
            realm=s
            file=s
            issuer=s
            force-no-chain
            force-issuer
            force-certificate-already-exists
            force-no-verify
            revoked

            alias=s
            gen|generation=s
            group=s
            token=s
        );

        # alias, gen, group, token are for alias shortcut
#            force-really-self-signed
#            force-issuer-not-found
#            force-certificate-already-exists


        __init();

        OpenXPKI::Server::Init::init({TASKS  => ['config_versioned','log','dbi_log','api','crypto_layer','dbi'], SILENT => 1, CLI => 1});

        if (!$params{file}) {
            die "You need to specify the certificate to import with --file\n";
        }

        __check_realm() if ($params{realm});

#       if ((!$params{alias} && $params{group}) || ($params{alias} && !$params{group})) {
#           die "You must always specify both --alias and --group \n";
#       }

        $ret = certificate_import();

    } elsif ($subcmd eq 'remove') {

        push @options_spec, qw(
            realm=s
            name=s
            force-is-issuer
        );
        __init();

        OpenXPKI::Server::Init::init({TASKS  => ['config_versioned','log','dbi_log','api','crypto_layer','dbi'], SILENT => 1, CLI => 1});

        __check_realm() if ($params{realm});

        $ret = certificate_remove();

    } elsif ($subcmd eq 'chain') {

        push @options_spec, qw(
            issuer=s
            issuer-realm=s
            realm=s
            name=s
            force-certificate-not-found
            force-issuer-certificate-not-found
        );
        __init();

        OpenXPKI::Server::Init::init({TASKS  => ['config_versioned','log','dbi_log','api','crypto_layer','dbi'], SILENT => 1, CLI => 1});

        $ret = certificate_chain();

    } elsif ($subcmd eq 'list') {

        push @options_spec, qw(
            realm=s
            all
            v+
        );
        __init();

        OpenXPKI::Server::Init::init({TASKS  => ['config_versioned','log','dbi_log','api','crypto_layer','dbi'], SILENT => 1, CLI => 1});

        __check_realm();

        $ret = certificate_list();
    }


} elsif ($cmd eq 'alias') {

    push @options_spec, qw(
      alias=s
      remove
      update
      notbefore=s
      notafter=s
      realm=s
      gen|generation=s
      group=s
      token=s
      filter=s
      identifier=s
      subject
      nogroup
    );
    __init();

    OpenXPKI::Server::Init::init({TASKS  => ['config_versioned','log','dbi_log','api','dbi'], SILENT => 1, CLI => 1});

    __check_realm();

    my $subcmd = shift || '';

    if ($params{remove} || $subcmd eq 'remove') {
        $ret = alias_del();
    } elsif ($params{update}  || $subcmd eq 'update') {
        $ret = alias_update();
    } elsif (!$params{identifier}) {
        $ret = alias_list();
    } else {
        $ret = alias_add();
    }
} elsif ($cmd eq 'key') {

    my $subcmd = shift || '';

    if ($subcmd eq 'list') {

        push @options_spec, qw(
          realm=s
        );
        __init();

        OpenXPKI::Server::Init::init({TASKS  => ['config_versioned','log','api','dbi'], SILENT => 1,});

        __check_realm();

        $ret = key_list();

    }
} elsif ($cmd eq 'hashpwd') {

    push @options_spec, qw(
          scheme|s=s
    );
    __init();

    if (!$params{scheme}) {
        $params{scheme} = 'ssha';
    } elsif ($params{scheme} !~ /^(sha|ssha|md5|smd5|crypt)$/) {
        die "Unsupported scheme - supported values: sha|ssha|md5|smd5|crypt\n";
    }

    $ret = hash_password();
} elsif ($cmd eq 'version') {
    print "Version (core): " . $OpenXPKI::VERSION::VERSION . "\n";
    $ret = 0;
}

};

if (ref $EVAL_ERROR eq "OpenXPKI::Exception") {
    print  OpenXPKI::i18n::gettext($EVAL_ERROR->message()) ."\n";
    map { print "   $_: " . $EVAL_ERROR->params->{$_} ."\n";  } keys %{$EVAL_ERROR->params};
    print "\n";
    exit 1;
} elsif (my $eval_err = $EVAL_ERROR) {
    die $eval_err;
    print "\n";
} elsif ($ret) {
    print "\n";
    pod2usage( -verbose => 0 ) if ($ret == 1 || $ret == 255);
    exit $ret;
}

exit 0;

1;


__END__

=head1 NAME

openxpkiadm - tool for management operations of OpenXPKI instances

=head1 USAGE

openxpkiadm COMMAND [SUBCOMMAND] [OPTIONS]

 Global options:
   --config DIR          Location of the configuration repository
                         optional, defaults to /etc/openxpki/config.d
   --instance|i NAME     Shortcut to set the config path to
                         /etc/openxpki/<instance>/config.d

 Commands:
   help                  brief help message
   man                   full documentation
   version               print program version and exit
   key                   Manage keys
   certificate           Manage certificates
   hashpwd               Create the salted hash for a password
   alias                 Manage the token alias table

=head1 ARGUMENTS

Available commands:

=head2 initdb

Command was removed, use provided sql schema dumps to create database.

=head2 key

Key management for OpenXPKI Tokens (including issuing CAs and subsystems).

Command options:

   --realm               PKI Realm to operate on

=head3 key management subcommands

=over 8

=item B<list>

Shows token key information for the specified realm, including
key algorithm, key length and secret splitting information.
TODO: Key info not implemented yet!

Lists keys together with a status flag, which can be one of the
following:

  c - token not defined in crypto.token
  + - key exists and file is non-empty
  0 - key exists but file is empty
  ! - key files does not exist (yet)


Example:

  openxpkiadm key list --realm 'Root CA'

=back

=head2 certificate

Starts a certificate management command and allows to list, install,
delete and connect certificates for the configured PKI Realms.

  openxpkiadm certificate <subcommand> <options>

=head3 certificate management subcommands

=over 8

=item B<list>

Subcommand options (optional):

   --realm                  PKI realm to operate on
   --all                    Show all certificates
   -v                       Show subject and issuer DN as well
   -v -v                    Show chain as well
   -v -v -v                 Show (nearly complete) database entry
   -v -v -v -v              Show pubkey and certificate data, too

Lists certificates present in the database for
the specified realm. If --all is not specified, only certificates
that have an alias defined for them are listed. --all lists all
certificates, regardless of whether they have an alias or not.
If --realm is left out, the certificates in all realms are listed
The number of -v's increases the verbosity (see above for what is
listed in which case).

=item B<import>

Subcommand options:

Mandatory:
  --file                    the PEM file to import from

Optional:
  --revoked                 import with status "revoked"
  --issuer                  the identifier of the issuer
  --realm                   PKI realm to import certificate to

Force options (use only if you exactly now what you are doing!):
  --force-no-chain (only without issuer)
        Import even if the chain is incomplete, set NULL as issuer
  --force-issuer
        Force the issuer setting even if the chain validation fails
  --force-certificate-already-exists
        Force update for an existing certificate
  --force-no-verify
        Build the chain but skip cryptographic verification

Once again, only use these options if you actually have to (the occasions
where this happens should be really, really rare). Note that force-no-chain
might result in a wrong issuers assignment if key identifiers or subjects are
ambiguous. Consider using explicit issuer in that cases if possible.

Adds a certificate to the database. The issuer is usually auto-detected and
needs to be given only in rare cases. By default the certificates are imported
into the global realm, if you want to add them to a specific one, you need to
specify it. Note that a certificate always inherits the realm of its issuer!

The command outputs the subject's DN, issuer's DN and the imported realm for
you to verify that you imported the correct certificate as well as a unique
identifier which can be used to globally reference the certificate
(i.e. for configuration or as an issuer). If you don't want to remember
the identifier, look into openxpkiadm certificate alias to find out
how to create a symbolic name for an identifier.

Examples:

  openxpkiadm certificate import --file cacert.pem

Import a certificate which issuer is not known in the "ServerCA" realm:

  openxpkiadm certificate import --file cacert.pem \
      --force-no-chain --realm ServerCA

You can create an alias directly on import by adding either alias,
generation/group or token to the command. This will execute the alias
command with those paramters for the imported certificate inline.

=item B<remove>

Subcommand options:

Mandatory:
  --name            The alias or identifier of the certificate

Optional:
  --realm           The PKI realm in which the alias is defined

Force options (use only if you now what you are doing!):
  --force-is-issuer Delete certificate even though it is the
                    issuer of another certificate in the database

Removes a certificate from the database.

Example:

  openxpkiadm certificate remove --realm 'Root CA' \
        --name 'Root CA 1'

=item B<chain>

Subcommand options:

 Mandatory:
  --realm               The PKI realm to operate in
  --name                The alias or identifier of the child
  --issuer              The alias or identifier of the parent

Optional:
  --issuer-realm        The realm in which the issuer alias
                        is defined

Force options (use only if you now what you are doing!):
  --force-certificate-not-found
        Ignore that the certificate of the child was not found
        in the DB
  --force-issuer-certificate-not-found
        Ignore that the certificate of the parent was not found
        in the DB

Once again, only use these options if you actually have to (the
occasions where this happens should be really, really rare).

Specifies subject/issuer relationship in order to set up certificate
chains. The certificates to be connected must already be present in
the database (see B<import>). As those connections are already set up
during --import, this command exists for changing the issuer if you
made an error. It also allows to specify an issuer that does not
agree with the information contained in the certificate (but outputs
a warning)

 Example:

openxpkiadm certificate chain --realm 'Root CA' \
     --name 'Subordinate CA 1' --issuer 'root1'

=back

=head2 alias

An alias is a symbolic name for a certificate in a specific realm.
OpenXPKI uses aliases to manage the crypto tokens for signer and
helper tokens. Several configs options and commands are able to
process aliases, too.

The selection of functional tokens is done based on the notbefore/notafter
date. To force certain behaviour (e.g time of a ca rollover), you can force
a custom notbefore/notafter date on the aliases.

Common options:
    --realm        PKI realm for the alias
    --identifier   The identifier of the certificate
    --notbefore    custom notbefore date to set
    --notafter     custom notafter date to set
                   accepted formats are epoch or yyyy-mm-dd hh:mm:ss
                   a literal 0 restores the certificates validity.

There are different ways to deal with aliases:

=over

=item B<list tokens>

If you pass a realm but no identifier, you will receive the list of
active tokens for all token groups, the current root certificate
and, if set, the upcoming root certificate as used by scep I<GetNexCACert>.

For items with custom notbefore/notafter settings, the certificate's value
is shown in brackets:

    upcoming root ca:
        Alias     : root-2
        Identifier: xGBSVo6N-9gpjB8UFll4TS-u-Eo
        NotBefore : 2014-01-01 00:00:00 (2013-06-17 13:54:34)
        NotAfter  : 2016-12-31 23:59:59 (2020-06-17 13:54:34)

To show the certificates subject besides the identifier, add --subject.

To show a list of all or all active tokens, you can add the filter parameter:

   --filter all or --filter active

You can also filter by a certain group name with --group <groupname>.

Specify --nogroup to list tokens that do not belong to a group.

=item B<add functional token with automatic group discovery>

Looks up the name of the associated group and finds the next generation
index by looking up the present aliases in the group. Recommended.

  --token  The name of the token type you want to add,
           e.g. certsign or datasafe.

Example:

    openxpkiadm alias --realm server-realm \
        --identifier rzg0GhTx81ioYGXADfuuIxFd9fw \
        --token certsign

=item B<add functional token with manual group configuration>

The alias is automatically set to <group>-<generation>, e.g. server-ca-1.
The generation identifier is increased by one from the latest one found
in the same group.

  --group   The name of the group (e.g. server-ca)

Example:

    openxpkiadm alias --realm server-realm \
        --identifier rzg0GhTx81ioYGXADfuuIxFd9fw \
        --group server-ca

=item B<explicit generation>

If you need to force a certain generation identifier, you can skip the
autodetection and provide the wanted index:

    --generation  The numeric index to use for this alias

This works with both methods above, token and group.

Example:

    openxpkiadm alias --realm server-realm \
        --identifier rzg0GhTx81ioYGXADfuuIxFd9fw \
        --group server-ca --generation 42

=item B<add non-functional alias>

Adds the alias leaving group and generation empty.

  --alias               The symbolic name for the certificate

Example:

    openxpkiadm alias --realm server-realm \
        --identifier rzg0GhTx81ioYGXADfuuIxFd9fw \
        --alias my-very-important-certificate

=item B<update alias>

Update notebefore/notafter date of an existing alias.

    --update        Indicates that you want to update anm existing entry
    --alias         You can select the alias by name rather than passing
                    the identifier.

Example:

     openxpkiadm alias --update --realm ca-one \
         --alias ca-one-signer-1
         --notbefore "2014-01-01:00:00:00"

This updates notbefore, notafter is not changed.

=item B<remove alias>

Remove the entry from the alias table.

  --remove          Indicates that the alias should be removed.
  --alias           You can select the alias by name rather than passing
                    the identifier.

Example:

    openxpkiadm alias --remove --realm server-realm \
        --identifier rzg0GhTx81ioYGXADfuuIxFd9fw \

    openxpkiadm alias --remove --realm server-realm \
        --alias server-ca-1

=back

=head2 hashpwd

Create the hash of a given password to be used with the internal user database.

Command options:

  --scheme   The hashing scheme to use, allowed values are
             ssha|sha|smd5|md5|crypt, default is ssha
             see also OpenXPKI::Server::Authentication::Password

Prompts for the password and prints the hashed value including the used
 scheme as defined in RFC2307.

=head1 DESCRIPTION

B<openxpkiadm> is the administrative frontend for controlling the OpenXPKI
installation.

=over 8

The openxpkiadm script returns a 0 exit value on success, and >0 if  an
error occurs.

=back







