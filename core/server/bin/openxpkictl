#!/usr/bin/env perl
use OpenXPKI;

# Core modules
use Getopt::Long;
use Pod::Usage;
use File::Spec;
use List::Util qw( any );
use FindBin qw( $Script );
use Module::Load ();

# CPAN modules
use Log::Log4perl qw( :easy :no_extra_logdie_message );

# Project modules
use OpenXPKI::Control::Role;
use OpenXPKI::Control::Server;

$OUTPUT_AUTOFLUSH = 1;

sub command_list {
    my @commands = sort
        map { my $cmd = $_; $cmd =~ s/^cmd_//; $cmd }
        grep { $_ =~ /^cmd_/ }
        OpenXPKI::Control::Role->meta->get_required_method_list;
    push @commands, 'help';
    return @commands;
}

sub scope_classes {
    return {
        client => 'OpenXPKI::Control::Client',
        server => 'OpenXPKI::Control::Server',
        terminal => 'OpenXPKI::Control::Terminal',
    };
}

sub show_pod (@args) {
    my %args = @args;
    my $commands = join "\n", map { '    ' . $_ } command_list;
    my $scopes = join "\n", map { '    ' . $_ } sort keys scope_classes->%*;

    # inject variables
    my $pod = delete $args{-oxi_pod} // do { local $/; <DATA> };
    $pod =~ s/%%CONTROL_SCRIPT%%/$Script/g;
    $pod =~ s/%%CONTROL_COMMANDS%%/$commands/g;
    $pod =~ s/%%CONTROL_SCOPES%%/$scopes/g;

    # print formatted POD
    open my $pod_fh, '<', \$pod;
    pod2usage(%args, -input => $pod_fh);
}

# Help
show_pod(-verbose => 1) unless @ARGV;

#
# Argument parsing
#
my $verbosity = 0;
my %opt = ('verbose' => \$verbosity);
Getopt::Long::Configure('pass_through','bundling');
GetOptions( \%opt, qw(
    help|?
    man
    verbose|v+
    config|c=s
    instance|i=s
));
Getopt::Long::Configure('no_pass_through');

show_pod(-exitstatus => 0, -verbose => 2) if $opt{man};
show_pod(-verbose => 1) if $opt{help};

my %role_attrs;
# $args->{SILENT} = $opt{quiet} ? 1 : 0;
if ($opt{config}) {
    $role_attrs{config_path} = File::Spec->rel2abs($opt{config});
} elsif ($opt{instance}) {
    $role_attrs{config_path} = sprintf '/etc/openxpki/%s/config.d/', $opt{instance};
}

#
# Log4perl
#
my $l4p_level;
my $l4p_layout = '%m%n';
if ($verbosity > 2) {
    $l4p_level = $TRACE;
    $l4p_layout = '%l %F:%L %m%n';
} elsif ($verbosity == 2) {
    $l4p_level = $DEBUG;
    $l4p_layout = '%m%n';
} elsif ($verbosity == 1) {
    $l4p_level = $INFO;
} else {
    $l4p_level = $ERROR;
}
Log::Log4perl->easy_init({ level => $l4p_level, layout => $l4p_layout });

#
# Command processing
#
my $command = shift;

if ($command eq 'version') {
    my $ver = OpenXPKI::Control::Server->new(%role_attrs)->get_version;
    say $ver;
    exit 0;

} elsif (any { $command eq $_} (command_list) ) {
    my $scope = shift
      or LOGDIE("Missing scope after command.\nAvailable scopes: " . join(', ', sort keys scope_classes->%*));
    my $class = scope_classes->{$scope}
      or LOGDIE("Unknown scope '$scope'.\nAvailable scopes: " . join(', ', sort keys scope_classes->%*));

    Module::Load::load($class);
    my $control = $class->new(%role_attrs);

    if ($command eq 'help') {
        # load POD from __DATA__ section of target package
        my $fh;
        eval '$fh = \*'.$class.'::DATA'; ## no critic (ProhibitStringyEval)
        my $pod = do { local $/; <$fh> } || "=head1 USAGE\n\nNo specific help available for scope '$scope'";
        show_pod(-oxi_pod => $pod);
    }

    # Extract command+scope specific positional args BEFORE any --options.
    my @args;
    while (@ARGV and $ARGV[0] !~ /^-/) {
        push @args, shift;
    }

    # Evaluate (extract) command+scope specific options
    my %options;
    if (my @getopts = $control->getopt_params($command)) {
        TRACE('GetOptions parameters: ' . Dumper \@getopts);
        GetOptions( \%options, @getopts ) or exit 1;
        $control->opts(\%options);
    }

    # Extract command+scope specific positional args AFTER any --options.
    push @args, @ARGV;
    $control->args(\@args);

    # Execute command
    TRACE(sprintf 'Calling %s->%s with options (%s) and arguments (%s)',
        $class,
        $command,
        join(', ', map { "$_=$options{$_}" } sort keys %options),
        join(', ', @args)
    );
    try {
        my $method = $control->can("cmd_$command");
        exit $control->$method;
    }
    catch ($err) {
        my $magic = 0xDEADBEEF;
        if (not blessed $err and $err =~ /$magic/) {
            say "Command '$command' is not implemented for '$scope'";
        } else {
            die $err;
        }
    }

    exit 0;

} else {
    LOGDIE("Unknown command '$command'.\nAvailable commands: " . join(', ', command_list));
}

__DATA__

=head1 NAME

openxpkictl - Start and stop OpenXPKI processes

=head1 USAGE

openxpkictl COMMAND SCOPE [OPTIONS]

COMMANDs:

%%CONTROL_COMMANDS%%

    version     Print OpenXPKI version and license info

SCOPEs:

%%CONTROL_SCOPES%%

=head1 OPTIONS

=over 8

=item B<--help>

Show brief help

=item B<--man>

Show manual page

=item B<--config|c PATH>

Use the configuration repository (base of yaml tree) below PATH.
Defaults to /etc/openxpki/config.d

=item B<--instance|i NAME>

Shortcut to set the config path when running multiple instances using
the proposed config path layout (/etc/openxpki/I<NAME>/config.d).

=back

=head1 DESCRIPTION

B<openxpkictl> is the start script for the OpenXPKI server process.

=over 8

The openxpkictl script returns a 0 exit value on success, and >0 if  an
error occurs.

=back
