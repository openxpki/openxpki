## OpenXPKI::Server::API::Smartcard.pm
##
## Written 2010 by Martin Bartosch for the OpenXPKI project
## Redesign using Connector by Oliver Welter 2012
## Copyright (C) 2005-2010 by The OpenXPKI Project

package OpenXPKI::Server::API::Smartcard;

use strict;
use warnings;
use utf8;
use English;

use OpenXPKI::Debug;
use OpenXPKI::Exception;
use OpenXPKI::Server::Context qw( CTX );
use OpenXPKI::Crypto::X509;
use DateTime;
use OpenXPKI::DateTime;
use OpenXPKI::i18n;

use Net::LDAP;
use Class::Std;
use MIME::Base64;
use Data::Dumper;
use Digest::SHA qw( sha1_hex );

sub START {
    # somebody tried to instantiate us, but we are just an
    # utility class with static methods
    OpenXPKI::Exception->throw(
        message => 'I18N_OPENXPKI_SERVER_API_SUBCLASSES_CAN_NOT_BE_INSTANTIATED',
    );
}

# named parameters:
# CERTFORMAT => DER|PEM|IDENTIFIER|BASE64 (allows degraded formats,
#   e. g. without newlines)
# CERTS => arrayref, entries contain raw cert data
sub sc_parse_certificates {
    ##! 1: 'init'
    my $self = shift;
    my $arg_ref = shift;

    if ($arg_ref->{CERTFORMAT} !~ m{ \A (?:DER|PEM|BASE64|IDENTIFIER) \z }xms) {
    OpenXPKI::Exception->throw(
        message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_PARSE_CERTIFICATES_INVALID_CERT_FORMAT',
        params  => {
        CERTFORMAT => $arg_ref->{CERTFORMAT},
        },
        log => {
        priority => 'error',
        facility => 'application',
        },
        );
    }

    my $certs = $arg_ref->{CERTS};

    my @result;

    foreach my $entry (@{$certs}) {
    my $data = $self->sc_analyze_certificate(
        {
        DATA       => $entry,
        CERTFORMAT => $arg_ref->{CERTFORMAT},
        });

    ##! 16: 'parsed certificate: ' . Dumper $data

    push @result, $data;
    }
    ##! 1: 'parsed certs: ' . Dumper \@result;
    return \@result;
}


# named parameters:
# SCMARTCARDID => scalar, token id read from token. format: TYPE_SERIAL
# SMARTCHIPID => scalar, chip id
# CERTFORMAT => see sc_parse_certificates
# CERTS => see sc_parse_certificates
# USERID => scalar, authenticated user (optional, if present may be
#           different from sc holder)
# WORKFLOW_TYPES => arrayref, existing workflow types to search (optional)
sub sc_analyze_smartcard {
    my $self = shift;
    my $arg_ref = shift;

    my $tokenid  = $arg_ref->{SMARTCARDID};
    my $chipid  = $arg_ref->{SMARTCHIPID};
    my $userid   = $arg_ref->{USERID};
    my $wf_types = $arg_ref->{WORKFLOW_TYPES};

    my $ser = OpenXPKI::Serialization::Simple->new();

    ##! 16: 'sc_analyze_smartcard() wf_types = $wf_types (' . Dumper($wf_types) . ')'

    if (defined $wf_types && (ref $wf_types ne 'ARRAY')) {
    OpenXPKI::Exception->throw(
        message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_SMARTCARD_INVALID_WORKFLOW_TYPES_UNEXPECTED_DATA_TYPE',
        params  => {
        DATA_TYPE => ref $wf_types,
        },
        log => {
        priority => 'error',
        facility => 'application',
        },
        );
    }

    CTX('log')->application()->info("Start analyze, ChipId: $chipid, TokenId: $tokenid");


    my $thisrealm = CTX('session')->data->pki_realm;

    my $config = CTX('config');

    ##! 16: ' Load policy map '
    # get policy settings from configuration
    my $policy = $self->_get_policy();

    my $result = {
        WF_TYPES => $wf_types,
        OVERALL_STATUS => 'green',
        SMARTCARD => {
            serialnumber => '',
            status => 'unknown',
            assigned_to => {},
            keyalg => 'RSA',
            keysize => 2048,
            #keyid => undef,
            token_chipid_match => 'unknown',
            user_data_source => '',
        },
        WORKFLOWS => undef,
        PROCESS_FLAGS => {
            # user is allowed to start a personalization workflow (complex
            # decision based on smartcard status, puk availability etc)
            allow_personalization => 0,

            # smartcard PIN is required for following operations (either
            # the user's pin or an autogenerated random pin)
            will_need_pin => 0,

            # smartcard puk is available in datapool
            puk_found_in_datapool => 0,

            # Policy Settings - can be set via connector config
            # if set to 1 the user may select his own pin,
            # otherwise the pin will be selected by the server
            allow_user_pin => $policy->get('allow_user_pin'),

            # policy setting: if set 0 no approval is required for user cert
            # issuance
            need_approval => $policy->get('need_approval') || 0,

            #  if true the token must be completely purged
            # before an unblock operation may happen (set from the token properties)
            purge_token_before_unblock => 0,

            #  if true the token must be completely purged
            # before a new personalization may happen
            purge_token_before_personalization => 0,

            # smartcard puk can be modified (set from the token properties)
            puk_is_writable => 1,

        },
        VALIDITY => {
            set_to_value => undef,
            set_by_type => '',
        },
    };

    my $holder_employee_id;

    #########################################################################
    # Based on the id of the card we need to obtain
    # * card status
    # * assigned employee
    # each is done in a seperate resolver call
    # The "lot id" is collected in the FetchPUK activity

    # Info about smartcard status is fetched from connector at
    # smartcard.cardstatus (scalar)

    my $res  = $config->walkQueryPoints('smartcard.cardstatus', $tokenid, 'get');

    ##! 32: ' SC Info: Token Id '.$tokenid.' - cardstatus ' . Dumper( $res->{VALUE} );
    # There should never be a match when tokenid ist not an exact match
    # So we should be able to omit the sanity check some lines below..

    if (!$res->{VALUE}) {

        OpenXPKI::Exception->throw(
            message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_SMARTCARD_TOKEN_NOT_FOUND',
            params  => {
                TOKENID => $tokenid,
            },
            log => {
                priority => 'error',
                facility => 'application',
            },
        );
    }

    my $cardstatus = $res->{VALUE};

    ##! 64: ' Sanity check token status word ' . $cardstatus
    # sanity check, only allow defined smartcard status
    if ($cardstatus !~ m{ \A (?:initial|activated|deactivated) \z }xms) {
        OpenXPKI::Exception->throw(
        message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_SMARTCARD_INVALID_SMARTCARD_STATUS',
        params  => {
            TOKENID => $tokenid,
            STATUS  => $cardstatus,
        },
        log => {
            priority => 'error',
            facility => 'application',
        },
        );
    } # Status Check

    # found and valid status - assign to result
    $result->{SMARTCARD}->{status} = $cardstatus;
    $result->{SMARTCARD}->{serialnumber} = $tokenid;

    ########################################################################
    # Find the employee id based on the smartcard id

    $res  = $config->walkQueryPoints('smartcard.card2user', $tokenid, 'get');

    $holder_employee_id = $res->{VALUE};

    if ( !$holder_employee_id ) {
        OpenXPKI::Exception->throw(
        message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_SMARTCARD_NO_EMPLOYEEID_FOR_TOKEN',
        params  => {
            TOKENID => $tokenid,
        },
        log => {
            priority => 'error',
            facility => 'application',
        },
        );
    }

    ##! 16: 'Employeeid is ' . $holder_employee_id


    CTX('log')->application()->debug("card is assigned to $holder_employee_id - status is $cardstatus");




    #### Step 3 #############################################################

    # New in Phase 2: Record or validate SMARTCARDID/SMARTCHIPID mapping.
    #
    # NOTE: If no chip ID was passed, just skip this whole block.
    #
    # Check datapool if a mapping exist (prevent card forgery)
    # If not, record the new mapping in the datapool.
    # Namespace: 'smartcard.smartchipid', key: SMARTCHIPID, value:SMARTCARDID.
    # Currently this is not done at all.)
    # If yes, validate that it matches the input of this call.
    # If this validation fails, log to the audit log
    # Result is also available in $result->{SMARTCARD}->{token_chipid_match}
    # Values are valid, new, unknown, mismatch

    if( defined $chipid ) {
        # Check for existing entry
        my $msg = CTX('api')->get_data_pool_entry( { KEY => $tokenid , NAMESPACE => 'smartcard.smartchipid' } );

        my $retval = $msg->{VALUE};
        $result->{SMARTCARD}->{token_chipid_match} = 'valid';

        # Not found - record it
        if (!$retval) {
            ##! 16: "Record card/chip relation Chip: $chipid - Token: $tokenid "
            CTX('api')->set_data_pool_entry( {
                KEY => $tokenid,
                NAMESPACE => 'smartcard.smartchipid',
                VALUE => $chipid ,
            } );
            $result->{SMARTCARD}->{token_chipid_match} = 'new';
        } elsif( $retval ne $chipid ) {
            $result->{SMARTCARD}->{token_chipid_match} = 'mismatch';
            CTX('log')->application()->warn("Chip Id of presented token mismatches recorded value! Token: $tokenid, Expected: $chipid, Presented: $retval");
        }
    }

    ##### Step 4 ############################################################

    # New in Phase 2: Determine current user by employee ID.

    # From Step 1 we know the employee ID. An employee ID maps to a person.
    # In order to obtain additional information about the Smartcard holder,
    # query configured data source (for now and very likely only LDAP
    # directory, check with tester if artificial data is required, in this
    # case a lookup needs to be implemented with a local configuration
    # file preceding the LDAP query).
    #
    # Values read from the directory:
    #
    # * givenName
    # * middleInitials
    # * surname
    # * mail
    # * list of Windows login IDs (loginids)
    #
    # The "wanted" Login Ids are no longer passed to this function but
    # queried from the frontend (and validated) in ApplyCSRPolicy step

    ##! 32: ' Find employee id '

    # Connector - Multi-Valued type
    my $employeeinfo = $config->walkQueryPoints( 'smartcard.employee', $holder_employee_id, { call => 'get_hash', deep => 1 } );

    if (!$employeeinfo) {
        OpenXPKI::Exception->throw(
        message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_SMARTCARD_SEARCH_PERSON_FAILED',
        params  => {
            EMPLOYEEID => $holder_employee_id
        },
        log => {
            priority => 'error',
            facility => 'application',
        },
        );
    }

    if (!$employeeinfo->{VALUE}->{mail}) {
        OpenXPKI::Exception->throw(
        message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_SMARTCARD_PERSON_ENTRY_DOES_NOT_HAVE_MAIL_ATTRIBUTE',
        params  => {
            EMPLOYEEINFO =>  $employeeinfo->{VALUE}
        },
        log => {
            priority => 'error',
            facility => 'application',
        },
        );
    }

    # loginids is expected to be an array ref but might be a scalar in result
    if (ref ($employeeinfo->{VALUE}->{loginids}) eq '') {
        my $loginid = $employeeinfo->{VALUE}->{loginids};
        $employeeinfo->{VALUE}->{loginids} = [ $loginid ];
    }

    # This should be ok as the hash should be correctly assembled by the connector
    $result->{SMARTCARD}->{assigned_to} = $employeeinfo->{VALUE};

    # Put the Employee Id to the context
    $result->{SMARTCARD}->{assigned_to}->{employee_id} = $holder_employee_id;

    # Record the name of the resolver where we got the user info from
    $result->{SMARTCARD}->{user_data_source} = $employeeinfo->{SOURCE};

    ##! 16: 'smartcard holder details from connector: ' . Dumper $employeeinfo

    CTX('log')->application()->debug("Holder Details: Name: $employeeinfo->{VALUE}->{cn}, Mail: $employeeinfo->{VALUE}->{mail}");

    # We use the mail address for the workflows
    my $card_owner = $employeeinfo->{VALUE}->{mail};
    $result->{SMARTCARD}->{assigned_to}->{card_owner} = $card_owner;

    # If a person changes his name or mail adress, we want to issue new certificates
    # We have the relevant info into the datapool as smartcard.user.currentid
    my $current_employee_info_dp = CTX('api')->get_data_pool_entry( {
        PKI_REALM => $thisrealm,
        NAMESPACE => 'smartcard.user.currentid',
        KEY => $holder_employee_id,
    } );

    my $employee_data_has_changed = '';
    my $current_employee_info;
    if ($current_employee_info_dp) {
        $current_employee_info = $ser->deserialize($current_employee_info_dp->{VALUE});
        foreach my $key (qw(givenname sn mail)) {
            if ($employeeinfo->{VALUE}->{$key} ne $current_employee_info->{$key}) {
                $employee_data_has_changed .= " $key: ".$current_employee_info->{$key}." -> ".$employeeinfo->{VALUE}->{$key};
                $current_employee_info->{$key} = $employeeinfo->{VALUE}->{$key};
            }
        }

        if ($employee_data_has_changed) {
            CTX('log')->application()->info("Holder Details have changed $employee_data_has_changed");
        }
    } else {
        foreach my $key (qw(givenname sn mail)) {
            $current_employee_info->{$key} = $employeeinfo->{VALUE}->{$key};
        }
    }

    # We put the serialized form directly here as the whole hash goes into the context
    $result->{SMARTCARD}->{assigned_to}->{currentid} = $ser->serialize( $current_employee_info );

    ##! 64: 'Recorded employee info (fingerprint) ' . Dumper $current_employee_info

    my $max_smartcards_per_user = $policy->get("cards.max_smartcards_per_user");

    if (defined $max_smartcards_per_user) {

        # TODO - check if user has too many cards
        my $smartcards_this_user = 1;

        ##! 16: 'checking for max number of smartcards per user'
        if ($smartcards_this_user > $max_smartcards_per_user ) {
            OpenXPKI::Exception->throw(
                message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_SMARTCARD_TOO_MANY_SMARTCARDS',
                params  => {
                    USER => $holder_employee_id,
                    SMARTCARD_COUNT => $smartcards_this_user,
                    #SMARTCARDS => join(';', map { $_->get_value('seealso') } @smartcard_entries),
                },
                log => {
                    priority => 'error',
                    facility => 'application',
                },
                );
        }
    } # end $max_smartcards_per_user


    #### Step 5 #############################################################
    # check membership of logged in user (if specified) in configured groups
    # Disabled for the moment!
    if (0 && defined $userid) {

        # Map the userid to a lookup key
        my $lookupid = $config->get('smartcard.groupinfo.usertokey');

        ##! 16: "userid $userid maps to $lookupid"

       foreach my $group_alias ($config->get_keys('smartcard.groupinfo.groups')) {

           my $process_flag = 'is_' . $group_alias;

           $result->{PROCESS_FLAGS}->{$process_flag} = 0;

           if (defined $lookupid) {
                ##! 16: 'checking membership for group ' . $group_alias
                ## FIXME - Needs testing
                if ($config->get("smartcard.groupinfo.checkgroup.$group_alias.$lookupid")) {
                    $result->{PROCESS_FLAGS}->{$process_flag} = 1;
                }
            }
       }
    }


    #### Step 6 #############################################################
    # Search for active workflows for the given card (only of workflow list is
    # passed). This operation is a convenience shortcut for the frontend
    # which may wish to continue a stalled personalization workflow.

    # search workflows
    if (defined $wf_types) {
        # get workflow information (existing workflows for card)
        foreach my $wf_type (@{$wf_types}) {
            $result->{WORKFLOWS}->{$wf_type} =
            CTX('api')->search_workflow_instances({
                TYPE => $wf_type,
                ATTRIBUTE => [
                    {
                        KEY => 'token_id',
                        VALUE => $tokenid,
                    },
                ],
                ORDER => 'WORKFLOW.WORKFLOW_LAST_UPDATE',
                REVERSE => 1,
            });
        }
    }

    #### Step 7 ##############################################################
    # Determine PUK status and possibly other properties of the Smartcard.
    # Depending on the PUK status set result values. The consumer of this
    # function call may need the information if the PUK is known and
    # available or if the PUK can be modified.
    # Here we only get the basic capabilities of the card and the
    # information on if we know the PUK. We don't fetch the actual PUK here,
    # this is done when it is actually needed in the workflow.
    # * boolean flag: PUK in Datapool (custom puk, that was set on the card
    #   earlier)
    # * boolean flag: PUK is writable (some Smartcards do not allow
    #   changing the PUK).
    # * boolean flag: purge token before unblock. if set to true by the API
    #   function, this indicates that the Smartcard must be completely
    #   erased (for security reasons) before an unblock operation can
    #   happen. True for RSA tokens (because we do not necessarily have a
    #   token - user assignment during unblock), false for most other cards.
    # * integer: supported keysize of the card

    # Check Datapool for exisiting puk and check for default puk if not
    my $puk_found = CTX('api')->get_data_pool_entry( {
        PKI_REALM => $thisrealm,
        NAMESPACE => 'smartcard.puk',
        KEY => $tokenid,
    } );

    if (defined $puk_found) {
       $result->{PROCESS_FLAGS}->{puk_found_in_datapool} = 1;

        CTX('log')->application()->debug("PUK for the card was found in datapool (TokenId $tokenid)");


    }

    ###########################################################################
    # Load PUK properties based on smartcard type from Config
    # We assume that the tokenid contains the cardtype as a prefix, seperated
    # by an underscore (<type>_<token nummer>)

    $tokenid =~ m{ \A (?:(\w+\d)_) }xms;
    my $token_family = $1;
    my $token_config;

    if (!$token_family || !($token_config = $config->get_hash("smartcard.cardinfo.properties.$token_family"))) {
        OpenXPKI::Exception->throw(
        message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_SMARTCARD_UNSUPPORTED_SMARTCARD_TYPE',
        params  => {
        TOKEN_ID => $tokenid,
        },
        log => {
        priority => 'error',
        facility => 'application',
        },
        );
    }

    $result->{PROCESS_FLAGS}->{puk_is_writable} = $token_config->{'puk_is_writable'} || 0;
    $result->{PROCESS_FLAGS}->{purge_token_before_unblock} = $token_config->{'purge_token_before_unblock'} || 0;
    $result->{PROCESS_FLAGS}->{purge_token_before_personalization} = $token_config->{'purge_token_before_personalization'} || 0;

    $result->{SMARTCARD}->{keysize} = $token_config->{'keysize'};

    #### Step 8 ###############################################################
    # This step prepares an output structure that can be used by the
    # frontend or the workflow to operate on the details of certificates
    # already on the card.
    # The input paramters to the sc_analyze_smartcard function contains a
    # list of Base64 encoded certificates as read from the Smartcard.
    # Iterate through this list and parse all certificates, generating a
    # hash array containing details on every single certificate.
    # Populate a return structure that contains the parsed version of all
    # certificates on the Smartcard.

    #### Rewrite starts here #################################################
    # The main hash which holds all informationen is $user_certs which has three
    # sections by_identifier, by_type, by_profile. Each section has an array ref
    # which contain (shared) instance of the approprate certificates

    my $user_certs = {
        by_identifier => {},
        by_type => { UNEXPECTED => [], FOREIGN => [] },
        by_profile => { UNKNOWN => [] },
        on_card => [],
    };

    # Initialize the lists with profiles and types from the configuration
    foreach my $type ($policy->get_keys('certs.type')) {
       $user_certs->{by_type}->{$type} = [];
    }

    ##! 32: ' Loading Profiles from xref.profile '
    my @profiles = $policy->get_keys('xref.profile');
    foreach my $profile ( @profiles) {
        $user_certs->{by_profile}->{$profile} = [];
    }

    #### Analyse Step 0 #####################################################
    # Get list of the users certificates (identifiers) from the datapool
    my $users_certificate_identifiers = CTX('api')->get_data_pool_entry( {
        PKI_REALM => $thisrealm,
        NAMESPACE => 'smartcard.user.certificate',
        KEY => $holder_employee_id,
    });

    my %certs_in_datapool;
    if ($users_certificate_identifiers) {
        %certs_in_datapool = map { $_ => 1; } @{$ser->deserialize($users_certificate_identifiers->{VALUE})};
    }

    ##! 32: ' User has ' . (scalar keys (%certs_in_datapool)) . ' certs registered in datapool '

    # Migration helper - check for certs on card but not in datapool
    my $update_datapool = 0;
    my $autodiscover = $policy->get("autodiscover_certificates");

    #### Analyse Step 1 #####################################################
    # Parse certificates from card
    my $certs_on_card = $self->sc_parse_certificates({
        CERTS => $arg_ref->{CERTS},
        CERTFORMAT => $arg_ref->{CERTFORMAT},
    });


    # Map $certs_on_card into the user_cert hash
    foreach my $cert (@$certs_on_card) {
        ##! 16: " Add certificate from card " . $cert->{IDENTIFIER}
        $cert->{ANALYZE} = { ONCARD => 1 };
        ##! 64: Dumper ($cert)
        $user_certs->{by_identifier}->{$cert->{IDENTIFIER}} = $cert;
        # Need to export them for SC API Call
        push @{$user_certs->{on_card}}, $cert;

        # Check if certificate is in datapool
        if (!$certs_in_datapool{$cert->{IDENTIFIER}} && $autodiscover) {
            $certs_in_datapool{$cert->{IDENTIFIER}} = 1;
            $update_datapool = 1;
            CTX('log')->application()->debug("Certificate $cert->{IDENTIFIER} found on card but not registered in datapool");

        }
    }

    CTX('log')->application()->info("Certificates found on card: " . join(', ', keys %{$user_certs->{by_identifier}}));

    if ($update_datapool) {
        my @certificate_identifiers = keys %certs_in_datapool;
        CTX('api')->set_data_pool_entry( {
            PKI_REALM => $thisrealm,
            NAMESPACE => 'smartcard.user.certificate',
            KEY => $holder_employee_id,
            VALUE => $ser->serialize( \@certificate_identifiers ),
            FORCE => 1
        } );
        CTX('log')->application()->info("Found unassigned certificates, updating datapool.");

    }

    #### Analyse Step 2 #####################################################
    # Load remaining certifiactes from database

    my @certs_to_load_from_db;
    CERT_FROM_DATAPOOL:
    foreach my $cert_id (keys %certs_in_datapool) {
        if ($user_certs->{by_identifier}->{$cert_id}) {
            ##! 64: " Certificate is already on card " . $cert_id
            next CERT_FROM_DATAPOOL;
        }
        ##! 64: "Certificate not on card " . $cert_id
        # Schedule certificate to load it from the database
        push @certs_to_load_from_db, $cert_id;
    }

    ##! 32: 'Need to load ' . scalar @certs_to_load_from_db . ' from database '
    CTX('log')->application()->info("Certificates to load from database: " . join(', ', @certs_to_load_from_db));


    if (scalar (@certs_to_load_from_db)) {
        my $sth = CTX('dbi')->select(
            from_join => "certificate req_key=req_key csr",
            columns => [
                'certificate.subject',
                'certificate.identifier',
                'certificate.status',
                'certificate.data',
                'certificate.notbefore',
                'certificate.notafter',
                'csr.profile',
            ],
            where => {
                'certificate.pki_realm' => $thisrealm,
                'certificate.identifier' => \@certs_to_load_from_db,
            },
        );

        # Push certificate to the user_cert hash
        while (my $entry = $sth->fetchrow_hashref) {
            my $identifier = $entry->{identifier};
            ##! 16: " Add certificate from database " . $identifier
            $user_certs->{by_identifier}->{$identifier} = {
                IDENTIFIER => $identifier,
                PROFILE    => $entry->{profile},
                SUBECT     => $entry->{subject},
                STATUS     => $entry->{status},
                NOTBEFORE  => $entry->{notbefore},
                NOTAFTER   => $entry->{notafter},
                ANALYZE    => { ONCARD => 0 }
            };
            ##! 64: Dumper ($user_certs->{by_identifier}->{$identifier})
        }
    }


    #### Analyse Step 3 #####################################################
    # The user_cert hash now contains all certificates that are either assigned
    # to the user via datapool or that were found on the card.
    # Now we populate the cross ref lists by type and profile
    foreach my $identifier (keys %{$user_certs->{by_identifier}}) {

        my $cert = $user_certs->{by_identifier}->{$identifier};

        # Try to get the type based on the profile, NB: requires that a profile may not be used in two types
        $cert->{CERTIFICATE_TYPE} = $policy->get( [ 'xref','profile', $cert->{PROFILE}, 'type' ] ) if ($cert->{PROFILE});

        # Force the profile to be "UNKNOWN" if it is not in the current map
        if (!$cert->{CERTIFICATE_TYPE}) {
            if ($cert->{PROFILE}) {
                $cert->{CERTIFICATE_TYPE} = 'UNEXPECTED';
                $cert->{PROFILE} = 'INVALID';
            } else {
                $cert->{CERTIFICATE_TYPE} = 'FOREIGN';
                $cert->{PROFILE} = 'UNKNOWN';
            }
        }

        push @{$user_certs->{by_type}->{$cert->{CERTIFICATE_TYPE}}},
            $user_certs->{by_identifier}->{$identifier};

        push @{$user_certs->{by_profile}->{$cert->{PROFILE}}},
            $user_certs->{by_identifier}->{$identifier};

        ##! 64: "Certificate $identifier has profile $cert->{PROFILE} and type $cert->{CERTIFICATE_TYPE}"
        CTX('log')->application()->debug("Certificate $identifier has profile $cert->{PROFILE} and type $cert->{CERTIFICATE_TYPE}");

    }

    #### Analyse Step 4 #####################################################
    # Iterate over the certificates grouped by type and set the status flags
    # according to the policy settings

    $result->{TASKS} = {
        PURGE => [],
        INSTALL => [],
        REVOKE => [],
        CREATE => [],
        SOFT => 1,
    };

    foreach my $type (keys %{$user_certs->{by_type}}) {

        CTX('log')->application()->debug("Start evaluation for type $type");


        # Sort the list by NOTBEFORE date
        @{$user_certs->{by_type}->{$type}}
            = sort { $b->{NOTBEFORE} <=> $a->{NOTBEFORE} }
                @{$user_certs->{by_type}->{$type}};

        # Fetch the policy settings for that type
        my $type_policy = {};
        foreach my $key (qw(promote_to_preferred_profile ignore_certificates_with_missing_private_key
            lead_validity required max_count max_age
            allow_renewal force_renewal escrow_key
            publish purge_valid purge_invalid revoke_unused renew_on_ownerchange)) {

            $type_policy->{$key} = $policy->get("certs.type.$type.$key") || 0;
        }
        $type_policy->{max_count} ||= 1;

        my @profiles = $policy->get_list("certs.type.$type.allowed_profiles");
        if (scalar @profiles) {
            $type_policy->{preferred_profile} = shift @profiles;
        } else {
            $type_policy->{preferred_profile} = '';
        }

        ##! 32: "Policy Settings for $type: " . Dumper($type_policy)

        my $cutoff_date;
        if ($type_policy->{max_age}) {
            $cutoff_date = OpenXPKI::DateTime::get_validity(
            {
                REFERENCEDATE => DateTime->now(),
                VALIDITY => $type_policy->{max_age},
                VALIDITYFORMAT => 'detect',
            });
            ##! 32: "Cutoff date set to $cutoff_date"
        }

        # Top check the limits
        my $cert_on_card_count = 0;

        # No certificates of that type
        if (scalar(@{$user_certs->{by_type}->{$type}}) == 0 && $type_policy->{preferred_profile})  {
            push @{$result->{TASKS}->{CREATE}}, $type;
            $result->{TASKS}->{SOFT} = 0;
            CTX('log')->application()->info("create initial certificate of $type");

        }

        CERT_ANALYZE_LOOP:
        foreach my $cert (@{$user_certs->{by_type}->{$type}}) {

            my $identifier = $cert->{IDENTIFIER};
            ##! 16: 'Process '  . $identifier
            $self->__check_against_policy({ CERT => $cert, POLICY => $type_policy, OWNERCHANGE => $employee_data_has_changed});

            # If this is the topmost certificate, we check the status to see if we need
            # to create a new certificate
            if ($cert_on_card_count == 0 && $cert->{VISUAL_STATUS} ne "green" && $type_policy->{preferred_profile}) {
                push @{$result->{TASKS}->{CREATE}}, $type;
                $result->{TASKS}->{SOFT} &&= $cert->{ANALYZE}->{SOFT};
                $cert_on_card_count++;
                CTX('log')->application()->info("add certificate of $type");

            }

            if ($cutoff_date) {
                my $notbefore = DateTime->from_epoch( epoch => $cert->{NOTBEFORE} );
                if (DateTime->compare($cutoff_date, $notbefore) > 0) {

                    $self->__check_actions_on_discard_candidate({ CERT => $cert, POLICY => $type_policy});

                    ##! 128: 'Discarding (cutoff date) - result: ' . Dumper ($cert)

                    if ($cert->{PROCESS_FLAGS}->{REVOKE}) {
                        push @{$result->{TASKS}->{REVOKE}}, $cert;
                        $result->{TASKS}->{SOFT} &&= $cert->{PROCESS_FLAGS}->{SOFT};
                        ##! 64: "certificate is beyond cutoff date, certificate will be revoked"
                        CTX('log')->application()->debug("certificate is beyond cutoff date, certificate $identifier will be revoked");

                    }

                    if ($cert->{PROCESS_FLAGS}->{PURGE}) {
                        push @{$result->{TASKS}->{PURGE}}, $cert;
                        $result->{TASKS}->{SOFT} &&= $cert->{PROCESS_FLAGS}->{SOFT};
                        ##! 64: "certificate is beyond cutoff date, certificate will be purged"
                        CTX('log')->application()->debug("certificate is beyond cutoff date, certificate $identifier will be purged");

                    }
                    next CERT_ANALYZE_LOOP;
                }
            }

            # More than allowed certificates on card (including created ones)
            if ($cert_on_card_count >= $type_policy->{max_count}) {
                $self->__check_actions_on_discard_candidate({ CERT => $cert, POLICY => $type_policy});

                ##! 128: 'Discarding (max count) - result: ' . Dumper ($cert)

                if ($cert->{PROCESS_FLAGS}->{REVOKE}) {
                    push @{$result->{TASKS}->{REVOKE}}, $cert;
                    $result->{TASKS}->{SOFT} &&= $cert->{PROCESS_FLAGS}->{SOFT};
                    ##! 64: "max_count for type $type reached, certificate will be revoked"
                    CTX('log')->application()->debug("max_count for type $type reached, certificate $identifier will be revoked");

                }

                if ($cert->{PROCESS_FLAGS}->{PURGE}) {
                    push @{$result->{TASKS}->{PURGE}}, $cert;
                    $result->{TASKS}->{SOFT} &&= $cert->{PROCESS_FLAGS}->{SOFT};
                    ##! 64: "max_count for type $type reached, certificate will be purged"
                    CTX('log')->application()->debug("max_count for type $type reached, certificate $identifier will be purged");

                }

                next CERT_ANALYZE_LOOP;
            }

            # If we are here, there are slots left to install suited certificates
            $self->__check_actions_on_install_candidate({ CERT => $cert, POLICY => $type_policy});

            ##! 128: 'Candidate - result: ' . Dumper ($cert)

            foreach my $action (qw(INSTALL REVOKE PURGE)) {
                if ($cert->{PROCESS_FLAGS}->{$action}) {
                    push @{$result->{TASKS}->{$action}}, $cert;

                    # We do not clear the soft-flag on install of additional certificates
                    # This will happen only if the max_count is raised during operation
                    if (!($cert_on_card_count > 0 && $action eq 'INSTALL')) {
                        $result->{TASKS}->{SOFT} &&= $cert->{PROCESS_FLAGS}->{SOFT};
                    }

                    ##! 64: "certificate will be $action 'ed due to policy"
                    CTX('log')->application()->debug("certificate $identifier of type $type will be $action 'ed due to policy");

                }
            }

            if ($cert->{FINAL_STATE}->{ONCARD}) {
                $cert_on_card_count++;
            }

            # The first certificate deployed on card is used for the lead validity computation
            if ($cert_on_card_count == 1 && $type_policy->{lead_validity} && !$result->{VALIDITY}->{set_by_type}) {
                ##! 32: ' Set overall validity by cert '.$identifier.' to ' . $cert->{NOTAFTER};
                $result->{VALIDITY}->{set_by_type} = $type;
                $result->{VALIDITY}->{set_to_value} = $cert->{NOTAFTER};
                CTX('log')->application()->info("Set validity based on $identifier to " . DateTime->from_epoch( epoch => $cert->{NOTAFTER} )->strftime("%F %T"));

            }

        }
    } # foreach type loop

    # We need a pin to purge or install certificates
    foreach my $action (qw(INSTALL PURGE CREATE)) {
        if (scalar ( @{$result->{TASKS}->{$action}} ) ) {
            $result->{PROCESS_FLAGS}->{will_need_pin} = 1;
            last;
        }
    }

    # Set the overall status
    if (!$result->{TASKS}->{SOFT}) {
        $result->{OVERALL_STATUS} = 'red';
    } else {
        $result->{OVERALL_STATUS} = 'green';
        # Overall status is not green if there is any action pending
        foreach my $action (qw(INSTALL REVOKE PURGE CREATE)) {
            if (scalar ( @{$result->{TASKS}->{$action}} ) ) {
                $result->{OVERALL_STATUS} = 'amber';
                last;
            }
        }
    }

    # allow_personalization is an alias for the overall_status
    $result->{PROCESS_FLAGS}->{allow_personalization} =  ($result->{OVERALL_STATUS} eq 'green' ? 0 : 1);

    ##! 16: 'overall status: ' . $result->{OVERALL_STATUS}
    CTX('log')->application()->info("Overall Status is $result->{OVERALL_STATUS}");


    # SC UI needs info about the certs on card
    $result->{PARSED_CERTS} = $user_certs->{on_card};
    $result->{CERT_TYPES} = $policy->get_keys('certs.type');

    ##! 32: 'analysis result: ' . Dumper $result
    return $result;

}

sub _get_policy {
    my $self = shift;
    my $arg_ref = shift;

    # Policy is now served from conenctor
    my $config = CTX('config');
    my $policy = $config->get_wrapper( 'smartcard.policy' );

    # This is currently only working inside one execution thread due to forking
    # We need to run the index only once
    if ($policy->get('xref.cached')) {
        ##! 8: 'policy already indexed'
        return $policy;
    }



    ###########################################################################
    ##! 8: 'indexing policy'
    my $ref;

    foreach my $type ( $policy->get_keys('certs.type') ) {

        my $isFirst = 1;
        foreach my $allowed_profile ( $policy->get_list("certs.type.$type.allowed_profiles") ) {
            ##! 16: "Profile: $allowed_profile"
            $policy->set(['xref','profile', $allowed_profile, 'type'], $type );
            if ($isFirst) {
                # first profile is preferred
                $policy->set(['xref','profile', $allowed_profile, 'preferred'], 1 );
                $isFirst = 0;
            }
        }
    }

    $policy->set('xref.cached', 1);

    return $policy;
}

# Die Statusflags entsprechen den Policy-Flags allow_renewal/force_renewal/escrow_key. Dazu bauen wir uns noch drei Hilfsflags:
# valid: nicht revoked, nicht innerhalb allow/force_renewal, preferred
# usable: auf der Karte oder escrow und key vorhanden
# soft: invalid kommt aus "allow_renewal" oder profile promotion
sub __check_against_policy {
    my $self = shift;
    my $args = shift;
    my $cert = $args->{CERT};
    my $policy = $args->{POLICY};
    my $ownerchange = $args->{OWNERCHANGE};


    my $identifier = $cert->{IDENTIFIER};

    ##! 16: "Do policy check on $identifier / $cert->{CERTIFICATE_TYPE}"
    $cert->{ANALYZE} = {
        # States
        VALID => 1, # not revoked and in validity period
        EXPECTED => 1, # preferred and not expiring
        USABLE => 0, # on card or restorable to card
        ALLOW_RENEWAL => 0, # weather period is met
        FORCE_RENEWAL => 0, # weather period is met
        PREFERRED => 0, # profile matches the preferred one
        SOFT => 1, # soft error (allow renewal, profile upgrade)
        %{$cert->{ANALYZE}}, # Has ONCARD already set, possibly more overrides
    };
    my $analyze = $cert->{ANALYZE};

    # cert is known by PKI and not in ISSUED state
    if (defined $cert->{STATUS} && ($cert->{STATUS} ne 'ISSUED')) {
       ##! 64: "$identifier is not in issued status"
       $analyze->{VALID} = 0;
       $analyze->{SOFT} = 0;
    }

    # check for owner change
    if ($ownerchange && $policy->{renew_on_ownerchange}) {
        $analyze->{EXPECTED} = 0;
    }

    # Check if it is the preferred profile
    if ($cert->{PROFILE} eq $policy->{preferred_profile}) {
        ##! 64: "$identifier is of preferred profile"
       $analyze->{PREFERRED} = 1;
    } elsif ($policy->{promote_to_preferred_profile}) {
        ##! 64: "$identifier needs profile update"
        # Promote is only a "soft" validity exception
        $analyze->{EXPECTED} = 0;
        CTX('log')->application()->debug("Certificate $identifier needs profile update ($cert->{PROFILE} to $policy->{preferred_profile})");

    }

    # Check if cert is usable (on card or escrow key exists)
    if ($analyze->{ONCARD}) {
         ##! 64: $identifier . ' is on card'
        $analyze->{USABLE} = 1;
    } elsif ($policy->{escrow_key}) {

        ##! 16: 'checking if private key is available for cert identifier ' . $identifier

        my $private_key_found = CTX('dbi')->select_one(
            from => 'datapool',
            columns => ['datapool_key'],
            where => {
                pki_realm    => CTX('session')->data->pki_realm,
                namespace    => 'certificate.privatekey',
                datapool_key => $identifier,
            },
        );

        if ($private_key_found) {
            ##! 16: 'private key found - certificate can be restored'
            $analyze->{USABLE} = 1;
        } else {
            ##! 16: 'private key not in datapool '
            CTX('log')->application()->info("Private key not found for escrow certificate [$identifier], dequeueing");

        }
    } else {
        ##! 64: $identifier . ' is unusable as not on card and not escrowed'
        $analyze->{SOFT} = 0;
    }


    # check if cert is within validity period
    my $now = DateTime->now();
    my $cert_notbefore = DateTime->from_epoch( epoch => $cert->{NOTBEFORE} );
    my $cert_notafter = DateTime->from_epoch( epoch => $cert->{NOTAFTER} );

    if (!((DateTime->compare($cert_notbefore, $now) < 0) && (DateTime->compare($now, $cert_notafter) < 0))) {
        $analyze->{VALID} = 0;
        $analyze->{SOFT} = 0;

        ##! 64: $identifier . ' is not in validity period'
        CTX('log')->application()->debug("Certificate $identifier is outside validity period ($cert->{NOTBEFORE} to $cert->{NOTAFTER})");

    } else {
        ##! 64: $identifier. ' is in validity period, check renewals'
        # Check for renewal - only possible during validity period
        foreach my $entry (qw( allow_renewal force_renewal )) {
            my $validity = $policy->{$entry};
            if ($validity) {
                my $renewal_date = OpenXPKI::DateTime::get_validity(
                {
                    REFERENCEDATE => $cert_notafter,
                    VALIDITY => $validity,
                    VALIDITYFORMAT => 'relativedate',
                });

                if (DateTime->compare($now, $renewal_date) > 0) {
                    $analyze->{uc($entry)} = 1;
                    $analyze->{EXPECTED} = 0;
                    # Soft only for allow_renewal
                    $analyze->{SOFT} = 0 if ($entry eq 'force_renewal');
                    ##! 64: "Validity: $entry is scheduled for $renewal_date - needs renewal"
                    CTX('log')->application()->debug("Validity: $entry is scheduled for $renewal_date - needs renewal");

                } else {
                    ##! 64: "Validity: $entry is scheduled for $renewal_date - no action"
                    CTX('log')->application()->debug("Validity: $entry is scheduled for $renewal_date - no action");

                }
            }
        }
    }

    if ($analyze->{VALID} && $analyze->{EXPECTED} && $analyze->{USABLE}) {
        $cert->{VISUAL_STATUS} = 'green';
    } elsif($analyze->{SOFT}) {
        $cert->{VISUAL_STATUS} = 'amber';
    } else {
        $cert->{VISUAL_STATUS} = 'red';
    }

    ##! 16: "$identifier analyzed: visual status is $cert->{VISUAL_STATUS}"
     CTX('log')->application()->info("Certificate $identifier analyzed, visual status is $cert->{VISUAL_STATUS}");


    ##! 32: "Analyze result of $identifier: " . Dumper( $cert->{ANALYZE} )
}

sub __check_actions_on_install_candidate {
    my $self = shift;
    my $args = shift;
    my $cert = $args->{CERT};
    my $policy = $args->{POLICY};
    my $discard = $args->{DISCARD} || 0;

    my $analyze = $cert->{ANALYZE};

    ##! 16: 'Check candidate actions on ' . $cert->{IDENTIFIER} . ' with analyze result ' . Dumper ($cert->{ANALYZE})

    $cert->{PROCESS_FLAGS} = {
        INSTALL => 0,
        PURGE => 0,
        REVOKE => 0,
        SOFT => $analyze->{SOFT},
    };

    $cert->{FINAL_STATE} = {
        ONCARD => $analyze->{ONCARD},
        VALID => $analyze->{VALID},
    };

    my $flags = $cert->{PROCESS_FLAGS};

    # Purge certifiates from card
    IF_PURGE: {
    if ($analyze->{ONCARD}) {

        # Purge valid certifiates - always a hard requirement
        if ($policy->{purge_valid} && $analyze->{VALID}) {
            CTX('log')->application()->debug("Certificate $cert->{IDENTIFIER} is valid and purged from card");

            $flags->{PURGE} = 1;
            $flags->{SOFT} = 0;
            last IF_PURGE;
        }

        if ($policy->{purge_invalid} && !$analyze->{VALID}) {
            # Purge invalid certifiates - soft requirement
            $flags->{PURGE} = 1;
            CTX('log')->application()->debug("Certificate $cert->{IDENTIFIER} is invalid and purged from card");

            last IF_PURGE;
        }

        # Look into the future - this certificate is superseeded by the current workflow
        if ($policy->{purge_invalid} && ($policy->{revoke_unused} && !$analyze->{EXPECTED})) {
            $flags->{PURGE} = 1;
            CTX('log')->application()->debug("Certificate $cert->{IDENTIFIER} will be superseeded and is purged from card");

            last IF_PURGE;
        }
    }
    } # /IF_PURGE


    # Check if certificate needs to be revoked (not usable or not expected)
    if ($policy->{revoke_unused} && $analyze->{VALID}) {
        if (!$analyze->{USABLE}) {
            $flags->{REVOKE} = 1;
            CTX('log')->application()->debug("Certificate $cert->{IDENTIFIER} is not usable and will be revoked");

        } elsif (!$analyze->{EXPECTED}) {
            $flags->{REVOKE} = 1;
            CTX('log')->application()->debug("Certificate $cert->{IDENTIFIER} is not expected and will be revoked");

        }
    }

    # Install stuff
    IF_INSTALL:{
    if (!$analyze->{ONCARD}) {

        # We never install unusable certificates
        if (!$analyze->{USABLE}) {
            last IF_INSTALL;
        }

        # Valid = restorable escrow certificate
        if (!$policy->{purge_valid} && ($analyze->{VALID} && !$flags->{REVOKE})) {
            $flags->{INSTALL} = 1;
            $flags->{SOFT} = 0;
            CTX('log')->application()->info("Certificate $cert->{IDENTIFIER} is valid/usable and restored to card");
            last IF_INSTALL;
        }

        # If purge_invalid is not requested, we install also invalid certificates
        # (former escrow certificates)
        if (!$policy->{purge_invalid} && (!$analyze->{VALID} || $flags->{REVOKE})) {
            $flags->{INSTALL} = 1;
            $flags->{SOFT} = 0;
            CTX('log')->application()->info("Certificate $cert->{IDENTIFIER} is invalid and restored to card");
            last IF_INSTALL;
        }

    }} #IF_INSTALL

    # Determine the final result
    $cert->{FINAL_STATE}->{ONCARD} = 0 if ($flags->{PURGE}) ;
    $cert->{FINAL_STATE}->{ONCARD} = 1 if ($flags->{INSTALL}) ;
    $cert->{FINAL_STATE}->{VALID} = 0 if ($flags->{REVOKE}) ;

    ##! 32: 'Process result ' . Dumper ($cert->{PROCESS_FLAGS}) . Dumper ($cert->{FINAL_STATE})
}

sub __check_actions_on_discard_candidate {
    my $self = shift;
    my $args = shift;
    my $cert = $args->{CERT};
    my $policy = $args->{POLICY};

    my $analyze = $cert->{ANALYZE};

    ##! 16: 'Check discard actions on ' . $cert->{IDENTIFIER} . ' with analyze result ' . Dumper ($cert->{ANALYZE})

    $cert->{PROCESS_FLAGS} = {
        INSTALL => 0,
        PURGE => 0,
        REVOKE => 0,
        SOFT => $analyze->{SOFT},
    };
    my $flags = $cert->{PROCESS_FLAGS};

    # Purge certifiate from card
    if ($analyze->{ONCARD}) {
         $flags->{PURGE} = 1;
         CTX('log')->application()->debug("Certificate $cert->{IDENTIFIER} is discarded and purged from card");

    }

    # Check if certificate needs to be revoked
    if ($policy->{revoke_unused} && $analyze->{VALID}) {
        $flags->{REVOKE} = 1;
        CTX('log')->application()->debug("Certificate $cert->{IDENTIFIER} is not expected and will be revoked");

    }

    # Final result
    $cert->{FINAL_STATE} = { ONCARD => 0, VALID => ( $analyze->{VALID} && !$flags->{REVOKE} ) };
    ##! 32: 'Process result ' . Dumper ($cert->{PROCESS_FLAGS}) . Dumper ($cert->{FINAL_STATE})
}

# takes a single certificate and parses it. cert may specified literally
# or as a cert identifier (in which case it must exist in the database)
# args:
# DATA: raw data of cert
# CERTFORMAT:
#   BASE64 (raw base64 will be converted correctly to DER)
#   DER
#   PEM
#   IDENTIFIER (DATA is interpreted as cert identifier to look up in db)
# DONTPARSE: 1 (optional)
#   Only acceptable for cert format 'IDENTIFIER'. If set, the certificate
#   fetched from the database will not be parsed, but only the cert information
#   from the database (CSR and CERTIFICATE table entries) will be propagated.
#
# returns data structure with parsed certificate information

sub sc_analyze_certificate {
    my $self = shift;
    my $arg_ref = shift;

    my $certformat = $arg_ref->{CERTFORMAT};
    my $dontparse  = $arg_ref->{DONTPARSE};
    my $data       = $arg_ref->{DATA};

    my $thisrealm   = CTX('session')->data->pki_realm;

    my $default_token = CTX('api')->get_default_token();

    ##! 16: 'default token obtained'

    if ($dontparse && ($certformat ne 'IDENTIFIER')) {
       OpenXPKI::Exception->throw(
            message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_CERT_PARSING_REQUIRED_FOR_CERTFORMAT',
            params  => {
                CERTFORMAT => $certformat,
            },
            log => {
                priority => 'error',
                facility => 'application',
           },
        );
    }

    if ($certformat eq 'BASE64') {
        $data = MIME::Base64::decode_base64($data);
        $certformat = 'DER';
    }
    if (! defined $data) {
        OpenXPKI::Exception->throw(
            message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_CERT_INVALID_DATA',
            params  => {
              CERT => $data,
            },
           log => {
              priority => 'error',
              facility => 'application',
           },
        );
    }

    if ($certformat eq 'DER') {
        ##! 16: 'converting DER to PEM'
        $data = $default_token->command({
            COMMAND => 'convert_cert',
            IN      => $certformat,
            OUT     => 'PEM',
            DATA    => $data,
        });
       $certformat = 'PEM';
    }

    my $x509;
    my $db_hash = {};
    my $identifier;
    if ($certformat eq 'PEM') {
        ##! 16: 'PEM Data: ' . $data
        $x509 = OpenXPKI::Crypto::X509->new(
           DATA => $data,
           TOKEN => $default_token,
        );
        $db_hash = {
           $x509->to_db_hash(),
        };
        $identifier = $db_hash->{IDENTIFIER};
    } elsif ($certformat eq 'IDENTIFIER') {
        $identifier = $data;
    } else {
        OpenXPKI::Exception->throw(
           message => 'I18N_OPENXPKI_SERVER_API_SMARTCARD_SC_ANALYZE_CERT_INVALID_CERTFORMAT',
           params  => {
            CERTFORMAT => $arg_ref->{CERTFORMAT},
           },
           log => {
              priority => 'error',
              facility => 'application',
           },
        );
    }

    # search certificate in database
    ##! 16: 'searching certificate with identifier: ' . $identifier

    my $cert_data = CTX('dbi')->select_one(
        from_join => "certificate req_key=req_key csr",
        columns => [
            'certificate.issuer_identifier',
            'certificate.status',
            'certificate.pki_realm',
            'certificate.data',
            'certificate.notbefore',
            'certificate.notafter',
            'csr.profile',
        ],
        where => {
            'certificate.identifier' => $identifier,
        },
    );

    # entry was found in the database
    if ($cert_data) {
        if (! (defined $x509 || $dontparse)) {
            # cert raw data was not supplied as an argument (but found in
            # the database)
            ##! 16: 'parsing certificate'
            $x509 = OpenXPKI::Crypto::X509->new(
              DATA => $cert_data->{data},
              TOKEN => $default_token,
            );

            $db_hash = { $x509->to_db_hash() };
        }

        # merge database query results with parsed cert
        ##! 16: 'merging certificate information from database'
        $db_hash = {
            %{$db_hash},
            IDENTIFIER        => $identifier,
            PKI_REALM         => $cert_data->{pki_realm},
            ISSUER_IDENTIFIER => $cert_data->{issuer_identifier},
            STATUS            => $cert_data->{status},
            PROFILE           => $cert_data->{profile},
            NOTBEFORE         => $cert_data->{notbefore},
            NOTAFTER          => $cert_data->{notafter},
        };

        ##! 16: 'cert data: ' . Dumper $db_hash
    }

    # remove raw cert data from output
    delete $db_hash->{DATA};

    # include validity information in iso format
    foreach my $entry (qw( NOTBEFORE NOTAFTER )) {
    my $date_obj = DateTime->from_epoch( epoch => $db_hash->{$entry});
    $db_hash->{$entry . '_ISO'} =
        OpenXPKI::DateTime::convert_date(
        {
            DATE => $date_obj,
            OUTFORMAT => 'printable',
        });
    }

    if (defined $x509) {
        my $modulus = $x509->get_parsed('BODY', 'MODULUS');
        ##! 16: 'modulus: ' . $modulus

        # compute PKCS#11 plugin compatible key id
        # remove leading null bytes for hash computation
        $modulus =~ s/^(?:00)+//g;
        $db_hash->{MODULUS_HASH} = sha1_hex(pack('H*', $modulus));
        ##! 16: 'pkcs11 plugin keyid hash: ' . $db_hash->{MODULUS_HASH}
    }

    # Windows UPN
    # FIXME
    $db_hash->{SUBJECT_UPN} = 'FIXME';

    ##! 16: 'parsed certificate: ' . Dumper $db_hash
    return $db_hash;
}

1;
__END__

=head1 Name

OpenXPKI::Server::API::Smartcard

=head1 Description

This API handles Smartcard specific calls.

=head1 Public functions

=head2 sc_parse_certificates

This function accepts a list of certificates and passes them to
C<sc_analyze_certificate>. The result is an array ref of the
result hash of this funtion.

=head3 Named function parameters

=over 8

=item * CERTS (mandatory)

This parameter is a list of certificates as read from the card.

=item * CERTFORMAT (mandatory)

see sc_analyze_certificate

=back

=head2 sc_analyze_certificate

This API function can be called by an OpenXPKI client in order to
get information on a certificate.
FIXME: Contains no SC specific info - can be moved to Object API

=head3 Named function parameters

=over 8

=item * DATA (mandatory)

The raw data of the certificate

=item * CERTFORMAT (mandatory)

Supported formats for the CERTS parameter are DER|PEM|BASE64|IDENTIFIER.
BASE64 will accept degraded formats (i. e. data without whitespace or padding).
If IDENTIFIER is selected, the function will retrieve the specified
certificate from the database and analyze it.

=item * DONTPARSE: 1 (optional)

Only acceptable for cert format 'IDENTIFIER'. If set, the certificate
fetched from the database will not be parsed, but only the cert information
from the database (CSR and CERTIFICATE table entries) will be propagated.

=back

=head3 Function results

The function will return a hash reference containing the detailed
information about the passed certificate with following structure (not all
entries may be set):

=over 8

=item * CERTIFICATE_SERIAL

=item * IDENTIFIER

=item * PKI_REALM

=item * SUBJECT

=item * ISSUER_DN

=item * ISSUER_IDENTIFIER

=item * EMAIL

=item * PUBKEY

=item * SUBJECT_KEY_IDENTIFIER

=item * AUTHORITY_KEY_IDENTIFIER

=item * NOTBEFORE

Seconds since Epoch

=item * NOTBEFORE_ISO

NotBefore date in ISO format

=item * NOTAFTER

Seconds since Epoch

=item * NOTAFTER_ISO

NotAfter date in ISO format

=item * STATUS

=item * PROFILE

=back

=head2 sc_analyze_smartcard

This API function can be called by an OpenXPKI client in order to
analyze the state of a given Smartcard.

=head3 Named function parameters

=over 8

=item * SMARTCARDID (mandatory)

This parameter shall be set to the Smartcard serial number
as read from the card. The API function will query this serial number
from the associated directory or repository and determine the
designated owner of the card.

The parameter format is defined in the Smartcard Interfaces document.

=item * SMARTCHIPID (optional)

The hardware chip id of the card. Should be set if available by the card driver
as it can prevent card forgery.

=item * USERID (optional)

If available, the user id of the currently logged in user should be
supplied by the caller. This may be different from the actual
Smartcard holder.

=item * CERTS (optional)

see sc_parse_certificates

=item * CERTFORMAT (mandatory if CERTS is given)

see sc_parse_certificates

=item * WORKFLOW_TYPES (optional)

This parameter is a list of workflow type names to be queried. If
specified, the analyze function will search for existing workflows of
the specified types that are owned by the holder of the Smartcard
of SMARTCARDID.

This is merely a convenience function that simply wraps the
search_workflow_instances API function.

=back

=head3 Function results

The function will return a complex data structure containing the
results of the Smartcard analysis.

These results are directly influenced by

=over 8

=item * internal status of the PKI database (e. g. existing certificates
for the user)

=item * external resources (such as LDAP directory contents)

=item * the passed parameters and

=item * the configured policy

=back

The results of the function can be directly used for decisions on how
the actual personalization should happen.

=head4 Return structure:

=over 8

=item * OVERALL_STATUS (scalar)

This is the global status of the Smartcard which can be directly
displayed by the frontend.

Possible values: 'green' (default), 'amber', 'red'

=item * SMARTCARD (hashref)

=back

The referenced structure contains the details of the Smartcard:

=over 8

=item * serialnumber (scalar)

Canonical serial number of the Smartcard

=item * status (scalar)

Smartcard status (initial|activated|deactivated)

=item * assigned_to (hashref)

Designated holder of the Smartcard. Items in the hash are determined
by the configuration at I<smartcard.employee>.

=item * user_data_source (scalar)

Origin of assigned_to (name of the resolver)

=item * keyalg (scalar)

Asymmetric algorith supported (preferred) by this Smartcard

=item * keysize (scalar)

Key size supported (preferred) by this Smartcard

=item * token_chipid_match (scalar)

If SMARTCHIPID was given, inicates if the chip id matches the card
serialnumber recorded in earlier personalizations.
Possible values are valid|new|mismatch.

=back

=over

=item * CERT_TYPES (array)

Lists all certificate types configured for this Smartcard. This is
identical to the keys of CERT_TYPE in the return structure.

=item * WORKFLOWS (hashref)

Returned data is identical to the result of the
search_workflow_instances() API function.

=item * PROCESS_FLAGS (hash of scalars, interpreted as booleans)

These flags can be used for decisions in the personalization workflow.

=back

=over 8

=item * allow_personalization

User is allowed to start a personalization workflow. This is an alias for the OVERALL_STATUS not being green.

=item * will_need_pin

Smartcard PIN is required for following operations (either the user's
pin or an autogenerated random pin)

=item * allow_user_pin

Policy setting: Allow user to enter pin (otherwise autogenerate random
pin -> pin unblock needed after completion).

=item * puk_is_writable

Smartcard puk can be modified

=item * puk_found_in_datapool

Smartcard puk is available in datapool

=item * need_approval

Policy setting: if set 0/false no approval is required for user
cert issuance

=item * purge_token_before_unblock

Policy setting: if true the token must be completely purged before
an unblock operation may happen

=item * purge_token_before_personalisation

Policy setting: if true the token must be completely purged before
a new personalization is made

=back

The flags marked as policy setting are taken from the policy config.
The purge_token_before* flags are set per card-type at
I<smartcard.cardinfo.properties.card_type.flag_name>, others are defined at
I<smartcard.policy.flag_name>.

=over 8

=item * VALIDITY (hashref)

Store information about forced notafter/validity setting

=item * set_to_value

Epoch timestamp which should be used as notafter date

=item * set_by_type

Certificate type which was used to determine the value

=item * TASKS (hashref)

Holds the information what should actually be done.

=back

=over 8

=item * CREATE (array ref)

Names of the certificate types that should be created.

=item * INSTALL (array ref)

List of certificates (descriptive hash) to install.

=item * PURGE (array ref)

List of certificates (descriptive hash) to purge.

=item * REVOKE (array ref)

List of certificates (descriptive hash) to revoke.

=item * PARSED_CERTS (array ref)

List of certificates found on the card. Each entry is a hash ref with the
merged results of sc_parse_certificate and the __check* methods.

=back
